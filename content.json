{"meta":{"title":"WYQ","subtitle":"WYQ's Blog","description":"记录成长中的点滴","author":"wangyaqi","url":"http://wyq2214368.github.io","root":"/"},"pages":[{"title":"about","date":"2019-04-12T08:29:34.000Z","updated":"2019-06-25T06:35:53.930Z","comments":true,"path":"about/index.html","permalink":"http://wyq2214368.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-12T08:28:01.000Z","updated":"2019-06-25T06:35:53.935Z","comments":true,"path":"categories/index.html","permalink":"http://wyq2214368.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2019-06-25T06:35:53.935Z","comments":true,"path":"friends/index.html","permalink":"http://wyq2214368.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-12T08:29:00.000Z","updated":"2019-06-25T06:35:53.935Z","comments":true,"path":"tags/index.html","permalink":"http://wyq2214368.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"让页面中的http请求转为https请求","slug":"nginx/让页面中的http请求转为https请求","date":"2019-07-04T16:00:00.000Z","updated":"2019-07-05T11:16:19.631Z","comments":true,"path":"2019/07/05/nginx/rang-ye-mian-zhong-de-http-qing-qiu-zhuan-wei-https-qing-qiu/","link":"","permalink":"http://wyq2214368.github.io/2019/07/05/nginx/rang-ye-mian-zhong-de-http-qing-qiu-zhuan-wei-https-qing-qiu/","excerpt":"","text":"由于项目业务升级，网站升级https协议。 在 HTTPS 承载的页面上不允许出现 http 请求，一旦出现就是提示或报错： Mixed Content: The page at &#39;https://www.example.com&#39; was loaded over HTTPS, but requested an insecure image ‘http://static.example.com/test.jpg’. This content should also be served over HTTPS. 因此即使使用到的域名对http请求已经强制了https，但是在页面中浏览器对于http请求压根就不会发送，那么就必需替换页面上所有的http为https，而我遇到的是个使用了十年的老系统，代码中有很多硬编码的http地址，一一替换的话要替换2万多行。。 于是从http协议入手，在响应header中添加upgrade-insecure-requests，即在php入口文件中添加： header(\"Content-Security-Policy: upgrade-insecure-requests\"); 或着也可以在由前端在html页面中添加meta： &lt;meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\" /> 或者在nginx配置中进行header的添加： server { listen 443; server_name www.example.com; error_log /logs/nginx/error.log; root /var/www/www.example.com; index index.php index.html index.htm; ssl on; ssl_certificate cert/test/test.pem; ssl_certificate_key cert/test/test.key; ssl_session_timeout 5m; #添加响应头 add_header Content-Security-Policy \"upgrade-insecure-requests'\"; location / { if (!-f $request_filename){ rewrite ^/(.*)$ /index.php?s=$1 last; break; } limit_except GET POST DELETE PUT { deny all; } } …… } 从而让浏览器对页面中的所有http请求，都升级为https协议发送请求，从而省去了逐一修改url的协议的麻烦。 以上，希望对大家有帮助。","categories":[{"name":"nginx","slug":"nginx","permalink":"http://wyq2214368.github.io/categories/nginx/"}],"tags":[{"name":"html","slug":"html","permalink":"http://wyq2214368.github.io/tags/html/"},{"name":"php","slug":"php","permalink":"http://wyq2214368.github.io/tags/php/"},{"name":"nginx","slug":"nginx","permalink":"http://wyq2214368.github.io/tags/nginx/"},{"name":"http","slug":"http","permalink":"http://wyq2214368.github.io/tags/http/"}]},{"title":"laravel将请求分派到另一个路由","slug":"php/laravel将请求分派到另一个路由","date":"2019-06-24T16:00:00.000Z","updated":"2019-06-25T06:35:53.925Z","comments":true,"path":"2019/06/25/php/laravel-jiang-qing-qiu-fen-pai-dao-ling-yi-ge-lu-you/","link":"","permalink":"http://wyq2214368.github.io/2019/06/25/php/laravel-jiang-qing-qiu-fen-pai-dao-ling-yi-ge-lu-you/","excerpt":"","text":"参考laravel手册 https://laravel.com/api/5.7/Illuminate/Routing/Router.html 最近有个业务场景是这样： //在管理模块中，要根据模块名动态跳转到该模块的controller来执行configs方法 //有类似如下两条路由 Route::get('manage/{module}', 'Common\\\\ManageController@configs'); Route::get('module1/config', 'Common\\\\Module1Controller@configs')->name('articles.configs'); 访问A路由，要动态的跳转B路由，即 Class ManageController { ... public function configs($module) { return redirect()->route(\"$module.configs\"); } } Class Module1Controller { ... public function configs(Request $request) { // do something } } 但这样会有302重定向，本来想通过nginx的location + rewrite来重写地址，来取出302的跳转。后来想了想觉得laravel这么优雅肯定有相关函数可以用。 于是查阅了learnku的laravel文档，但没有找到，google查阅前几页也没有提到解决方案，然后自己查了查laravel原始文档，发现Router类提供了responseWithRoute方法，于是将Controller修改如下： Class ManageController { ... public function configs($module) { request()->merge(['module' => $module]); //将参数值添加到request中 return Route::respondWithRoute(\"$module.configs\"); } } 更多可用方法可进一步查阅文档。 特此记个笔记，希望对同学们有帮助～","categories":[{"name":"php","slug":"php","permalink":"http://wyq2214368.github.io/categories/php/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://wyq2214368.github.io/tags/laravel/"}]},{"title":"laravel5.7安装jwt-auth的正确方法完整流程","slug":"php/laravel5.7安装jwt-auth的正确方法完整流程","date":"2019-06-10T16:00:00.000Z","updated":"2019-06-25T06:35:53.924Z","comments":true,"path":"2019/06/11/php/laravel5.7-an-zhuang-jwt-auth-de-zheng-que-fang-fa-wan-zheng-liu-cheng/","link":"","permalink":"http://wyq2214368.github.io/2019/06/11/php/laravel5.7-an-zhuang-jwt-auth-de-zheng-que-fang-fa-wan-zheng-liu-cheng/","excerpt":"","text":"由于没有完整的Laravel 5.7与jwt-auth集成的指南，官网的文档陈旧不更新，所以我决定创建一个。我假设你有一个Laravel支持auth的项目。 安装包jwt-auth将包添加到composer.json \"require\": { ... \"tymon/jwt-auth\": \"1.0.0-rc.3\" } 然后按命令更新composer composer update 设置配置生成密钥php artisan jwt:secret 发布配置文件php artisan vendor:publish --provider=\"Tymon\\JWTAuth\\Providers\\LaravelServiceProvider\" 打开app.php并添加以下行在’aliases array’数组中 'JWTAuth'=> Tymon\\JWTAuth\\Facades\\JWTAuth::class， 'JWTFactory'=> Tymon\\JWTAuth\\Facades\\JWTFactory::class， 更新用户模型打开User.php并为模型实现JWTSubject use Tymon\\JWTAuth\\Contracts\\JWTSubject; class User extends Authenticatable implements JWTSubject 并在模型中添加2个方法（在未完成的官方指南中阅读有关这些功能的更多信息） public function getJWTIdentifier（）{ return $ this-> getKey（）; } public function getJWTCustomClaims（）{ return []; } 更新配置auth.php打开config/auth.php并将API的保护驱动程序更改为’jwt’（默认为令牌） 'guards'=> [ ... 'api'=> [ 'driver'=>'jwt'， 'provider'=>'users'， ]， ]， 创建登录控制器创建controller用于login、logout、refresh等 &lt;?php namespace App\\Http\\Controllers\\Auth; use Illuminate\\Support\\Facades\\Auth; use App\\Http\\Controllers\\Controller; class JwtAuthController extends Controller { /** * Create a new AuthController instance. * 要求附带email和password（数据来源users表） * * @return void */ public function __construct() { $this->middleware('jwt.auth', ['except' => ['login']]); // 另外关于上面的中间件，官方文档写的是『auth:api』 // 但是我推荐用 『jwt.auth』，效果是一样的，但是有更加丰富的报错信息返回 } /** * Get a JWT via given credentials. * * @return \\Illuminate\\Http\\JsonResponse */ public function login() { $credentials = request(['email', 'password']); if (! $token = auth('api')->attempt($credentials)) { return response()->json(['error' => 'Unauthorized'], 401); } return $this->respondWithToken($token); } /** * Get the authenticated User. * * @return \\Illuminate\\Http\\JsonResponse */ public function me() { return response()->json(auth('api')->user()); } /** * Log the user out (Invalidate the token). * * @return \\Illuminate\\Http\\JsonResponse */ public function logout() { auth('api')->logout(); return response()->json(['message' => 'Successfully logged out']); } /** * Refresh a token. * 刷新token，如果开启黑名单，以前的token便会失效。 * 值得注意的是用上面的getToken再获取一次Token并不算做刷新，两次获得的Token是并行的，即两个都可用。 * @return \\Illuminate\\Http\\JsonResponse */ public function refresh() { return $this->respondWithToken(auth('api')->refresh()); } /** * Get the token array structure. * * @param string $token * * @return \\Illuminate\\Http\\JsonResponse */ protected function respondWithToken($token) { return response()->json([ 'access_token' => $token, 'token_type' => 'bearer', 'expires_in' => auth('api')->factory()->getTTL() * 60 ]); } } 创建路由打开routes/api.php然后添加一些路由 Route::group(['prefix' => 'auth'], function () { Route::post('login', 'Auth\\\\JwtAuthController@login'); Route::post('logout', 'Auth\\\\JwtAuthController@logout'); Route::post('refresh', 'Auth\\\\JwtAuthController@refresh'); Route::post('me', 'Auth\\\\JwtAuthController@me'); }); 然后在标头请求中添加“Authorization：Bearer {token}” 如果你想捕获异常在你的app/Exceptions/Handler.php中捕获’render’函数中的错误。 use Symfony\\Component\\HttpKernel\\Exception\\UnauthorizedHttpException; …… if ($exception instanceof UnauthorizedHttpException) { $preException = $exception->getPrevious(); if ($preException instanceof \\Tymon\\JWTAuth\\Exceptions\\TokenExpiredException) { return response()->json(['error' => 'TOKEN_EXPIRED']); } else if ($preException instanceof \\Tymon\\JWTAuth\\Exceptions\\TokenInvalidException) { return response()->json(['error' => 'TOKEN_INVALID']); } else if ($preException instanceof \\Tymon\\JWTAuth\\Exceptions\\TokenBlacklistedException) { return response()->json(['error' => 'TOKEN_BLACKLISTED']); } if ($exception->getMessage() === 'Token not provided') { return response()->json(['error' => 'Token not provided']); } } 就这样。 翻译自：https://medium.com/@hdcompany123/laravel-5-7-and-json-web-tokens-tymon-jwt-auth-d5af05c0659a并做了适当修改,希望能够帮助到各位同学。","categories":[{"name":"php","slug":"php","permalink":"http://wyq2214368.github.io/categories/php/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://wyq2214368.github.io/tags/laravel/"},{"name":"jwt-auth","slug":"jwt-auth","permalink":"http://wyq2214368.github.io/tags/jwt-auth/"}]},{"title":"Websokcet 实现mini聊天室","slug":"php/websocket—mini聊天室","date":"2019-05-20T16:00:00.000Z","updated":"2019-06-25T06:35:53.925Z","comments":true,"path":"2019/05/21/php/websocket-mini-liao-tian-shi/","link":"","permalink":"http://wyq2214368.github.io/2019/05/21/php/websocket-mini-liao-tian-shi/","excerpt":"","text":"前端经常需要与服务器进行持续的通讯以保持双方信息的同步，long long ago 我们会使用长轮询的方式来实现比如: setInterval(function() { $.get(\"/api/getData\", function(data, status) { console.log(data); }); }, 10000); 每隔10秒向服务器同步一次数据，这种方式缺点很明显: 每次请求都需要新建HTTP连接 只能是客户端向服务器的单向请求，服务器无法主动请求。 无法即时更新，就算将时间间隔调整为1秒，同时有1万个客户端打开，服务器也受不了。 那有没有一种像打电话一样，接通了之后双方有事就可以直接通知的呢，websocket就很好的满足了这个需求。 websokcet WebSocket 是基于 TCP 的独立的协议。它与 HTTP 唯一的关系是它的握手是由 HTTP 服务器解释为一个 Upgrade 请求 WebSocket 的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。其他特点包括： 建立在 TCP 协议之上，服务器端的实现比较容易。 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443 ，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 数据格式比较轻量，性能开销小，通信高效。 可以发送文本，也可以发送二进制数据。 没有同源限制，客户端可以与任意服务器通信。 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 推荐这篇文章 WebSocket 详解 websokcet 客户端 Chrome/Firefox/高版本IE/Safari等浏览器内置了JS语言的WebSocket客户端 微信小程序开发框架内置的WebSocket客户端 异步的PHP程序中可以使用Swoole\\Http\\Client作为WebSocket客户端 apache/php-fpm或其他同步阻塞的PHP程序中可以使用swoole/framework提供的同步WebSocket客户端 非WebSocket客户端不能与WebSocket服务器通信 简易的js websokcet 客户端&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>&lt;/title> &lt;meta charset=\"UTF-8\"> &lt;script type=\"text/javascript\"> if(window.WebSocket){ var webSocket = new WebSocket(\"ws://10.201.10.242:5200\"); webSocket.onopen = function (event) { //webSocket.send(\"Hello,WebSocket!\"); }; webSocket.onmessage = function (event) { var content = document.getElementById('content'); if(event.data instanceof Blob) { var img = document.createElement(\"img\"); img.src = window.URL.createObjectURL(event.data); content.appendChild(img); }else { content.innerHTML = content.innerHTML.concat('&lt;p style=\"margin-left:20px;height:20px;line-height:20px;\">'+event.data+'&lt;/p>'); } }; var sendMessage = function(){ var data = document.getElementById('message').value; webSocket.send(data); document.getElementById('message').value = ''; } }else{ console.log(\"您的浏览器不支持WebSocket\"); } &lt;/script> &lt;/head> &lt;body> &lt;div style=\"width:600px;margin:0 auto;border:1px solid #ccc;\"> &lt;div id=\"content\" style=\"overflow-y:auto;height:300px;\">&lt;/div> &lt;hr/> &lt;div style=\"height:40px\"> &lt;input type=\"text\" id=\"message\" style=\"margin-left:10px;height:25px;width:450px;\"> &lt;button onclick=\"sendMessage()\" style=\"height:28px;width:75px;\">发送&lt;/button> &lt;/div> &lt;/div> &lt;/body> &lt;/html> websokcet 服务端 使用 swoole的swoole_websocket_server 来搭建websokcet的服务端 使用 swoole的内存表swoole_table 来存储数据，线上项目还是建议使用redis &lt;?php class WebSocketServer { private $config; private $table; private $server; /** * @param array $config 配置文件 ['host'=>'' , 'port'=>''] */ public function __construct($config) { // 内存表 实现进程间共享数据，也可以使用redis替代 $this->createTable(); // 实例化配置 $this->config = $config； } public function run() { $this->server = new Swoole\\WebSocket\\Server( $this->config['host'], $this->config['port'] ); $this->server->on('open', [$this, 'open']); $this->server->on('message', [$this, 'message']); $this->server->on('close', [$this, 'close']); $this->server->start(); } public function open(Swoole\\WebSocket\\Server $server, Swoole\\Http\\Request $request) { $user = [ 'fd' => $request->fd, 'name' => 'S'. $request->fd, // 这里就随便写了,做登陆设计会有身份 ]; // 放入内存表 $this->table->set($request->fd, $user); $server->push($request->fd, json_encode( array_merge(['user' => $user], ['all' => $this->allUser()], ['type' => 'openSuccess']) ) ); } private function allUser() { $users = []; foreach ($this->table as $row) { $users[] = $row; } return $users; } public function message(Swoole\\WebSocket\\Server $server, Swoole\\WebSocket\\Frame $frame) { $this->pushMessage($server, $frame->data, 'message', $frame->fd); } /** * 推送消息 * * @param \\swoole_websocket_server $server * @param string $message * @param string $type * @param int $fd */ private function pushMessage(Swoole\\WebSocket\\Server $server, string $message, string $type, int $fd) { $message = htmlspecialchars($message); $datetime = date('Y-m-d H:i:s', time()); $user = $this->table->get($fd); foreach ($this->table as $item) { // 自己不用发送 也可以发 看前端怎么设计 if ($item['fd'] == $fd) { continue; } $server->push($item['fd'], json_encode([ 'type' => $type, 'message' => $message, 'datetime' => $datetime, 'user' => $user ])); } } /** * 客户端关闭的时候 * * @param \\swoole_websocket_server $server * @param int $fd */ public function close(Swoole\\WebSocket\\Server $server, int $fd) { $user = $this->table->get($fd); $this->pushMessage($server, \"{$user['name']}离开聊天室\", 'close', $fd); $this->table->del($fd); } /** * 创建内存表 */ private function createTable() { $this->table = new Swoole\\Table(1024); $this->table->column('fd', Swoole\\Table::TYPE_INT); $this->table->column('name', Swoole\\Table::TYPE_STRING, 255); $this->table->create(); } } mini聊天室 实战 照着webim搭建的一个聊天项目chat,涉及swoole,websocket,laravels等知识点 聊天室入口 后台入口 主要知识点 使用Laravel 快速搭建后台管理系统，这里使用的是之前集成的一个项目 niftyAdmin，Laravel5.5。 集成Laravels插件来使用Swoole的功能。 通过Nginx反向代理Swoole来加速HTTP服务，提高并发。 通过Swoole将Laravel常驻内存需要解决的一些注意事项。 在Laravel中使用多表登陆，前后台用户分开登陆管理，直接使用的Laravels的guards来处理。 通过Swoole来搭建高性能的Websocket的服务。 使用Swoole的异步Task功能来Push Websokcet 的Message。 使用Swoole的Tabel的直接管理一些不重要的数据。 主要功能 可以在聊天室群聊，也可以私聊。 通过laravels使用swoole搭建websocket 服务。 使用Task 异步发送websocket message 提高性能。 使用swoole_table 存储数据，如果是生产环境建议还是改成redis。 主要改动 新增一个聊天室后台，设置了onRequest回调，WebSocket\\Server同时作为http服务器。 后台可以管理聊天室，主要是新增和查看聊天房间 链接。 支持多表登陆,聊天用户管理,后台用户管理分开。 新增自动登录注册，也就是说页面会记住当前登录用户，不需要每次刷新抖登录。 新增小爱同学智能聊天，@小爱 聊天 ，他就会回复你哦，这个机器人很笨。 搭建流程 git clone https://github.com/yujiarong/chat composer install php artisan key:generate composer里面应该集成了脚本 php artisan migrate 数据表迁移 php artisan laravels publish 发布laravels的配置文件 修改配置文件 `.env` 里面的 `JS_DOMIND` 图片域名 ，`WS_SERVER` JSd的websokcet连接地址 `.env` 里面的 `LARAVELS_LISTEN_IP`和`LARAVELS_LISTEN_PORT`用于swoole的启动监听地址 nginx 使用以下的配置,后台域名HTTP访问直接代理到laravels,websocket直接使用ip+port访问。 upstream laravels { # 通过 IP:Port 连接 server 127.0.0.1:9090 weight=5 max_fails=3 fail_timeout=30s; # 通过 UnixSocket Stream 连接，小诀窍：将socket文件放在/dev/shm目录下，可获得更好的性能 #server unix:/xxxpath/laravel-s-test/storage/laravels.sock weight=5 max_fails=3 fail_timeout=30s; #server 192.168.1.1:5200 weight=3 max_fails=3 fail_timeout=30s; #server 192.168.1.2:5200 backup; keepalive 16; } server { listen 80; server_name chat.dwyjr.cn; root /data/web/chat/public/; error_log /data/web/chat/storage/logs/error.log error; access_log /data/web/chat/storage/logs/access.log main; index index.php; location / { try_files $uri @laravels; } location @laravels { # proxy_connect_timeout 60s;//看情况设置 # proxy_send_timeout 60s; # proxy_read_timeout 120s; proxy_http_version 1.1; proxy_set_header Connection \"\"; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Real-PORT $remote_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header Scheme $scheme; proxy_set_header Server-Protocol $server_protocol; proxy_set_header Server-Name $server_name; proxy_set_header Server-Addr $server_addr; proxy_set_header Server-Port $server_port; proxy_pass http://laravels; } } 开启使用 ./bin/laravels start 就可以开始了,后台挂起加 -d,这里通过Laravels来使用swoole _ _ _____ | | | |/ ____| | | __ _ _ __ __ ___ _____| | (___ | | / _` | '__/ _` \\ \\ / / _ \\ |\\___ \\ | |___| (_| | | | (_| |\\ V / __/ |____) | |______\\__,_|_| \\__,_| \\_/ \\___|_|_____/ Speed up your Laravel/Lumen >>> Components +---------------------------+---------+ | Component | Version | +---------------------------+---------+ | PHP | 7.1.10 | | Swoole | 4.2.1 | | LaravelS | 3.5.2 | | Laravel Framework [local] | 5.5.45 | +---------------------------+---------+ >>> Protocols +----------------+--------+-------------------------------+--------------+ | Protocol | Status | Handler | Listen At | +----------------+--------+-------------------------------+--------------+ | Main HTTP | On | Laravel Framework | 0.0.0.0:9090 | | Main WebSocket | On | App\\Services\\WebSocketService | 0.0.0.0:9090 | +----------------+--------+-------------------------------+--------------+ 遇到的坑 基于swoole，将HTTP服务和Websocket服务整合在一起，使用laravels插件，swoole是常驻内存的,所以单例对象的使用是非常要注意的，Laravel内有很多功能使用单例模式。 Laravel的Controller里的构造方法如果初始化了一些参数，初始化后每次请求都是一样的，除非worker重启，这里如果遇到问题则每次请求后需要手动重置Controller。 某些服务提供者在加入了swoole之后因为会出现问题在，需要每次请求后重置，可以加在config/laravels.php的register_providers数组中。 如果使用到了Session一定要把config/laravels.php的cleaners中SessionCleaner和AuthCleaner开启，原因和上面一样。 若按照上面这样设置了之后还是有问题，则自己手动使用中间件清理或者重新绑定服务，比如以下方式。 &lt;?php namespace App\\Http\\Middleware; use Closure; use Route; use Log; class SwooleCleaner { /** * 使用swoole时 清理一些常驻内存有问题的实例 * 因控制器是单例，会常驻于内存，控制器中使用了静态变量,或者在构造函数__construct() 初始化了一些东西，就需要重置这个控制器 * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public $resetProvider = [ 'datatables.request' => \\Yajra\\DataTables\\Utilities\\Request::class, //如果不清理，这个插件搜索的时候就会出问题。 ]; public function handle($request, Closure $next) { if (PHP_SAPI === 'cli') { $this->resetProvider(); $response = $next($request); if(isset(Route::current()->controller )){ unset( Route::current()->controller ); } Log::info( \"Swoole 请求之后删除controller\"); return $response ; }else{ return $next($request); } } /* * 重新绑定一些服务提供者,有些服务提供者有 boot()有初始化可能需要更多的操作 */ public function resetProvider(){ foreach ($this->resetProvider as $key => $provider) { if(app($key)){ Log::info(\"Swoole 重置 {$key}\"); app()->singleton($key, function ()use($provider) { return new $provider; }); } } } }","categories":[{"name":"php","slug":"php","permalink":"http://wyq2214368.github.io/categories/php/"}],"tags":[{"name":"websokcet","slug":"websokcet","permalink":"http://wyq2214368.github.io/tags/websokcet/"}]},{"title":"使用Swoole提升Laravel的性能","slug":"php/laravel-optimize","date":"2019-05-13T16:00:00.000Z","updated":"2019-06-25T06:35:53.923Z","comments":true,"path":"2019/05/14/php/laravel-optimize/","link":"","permalink":"http://wyq2214368.github.io/2019/05/14/php/laravel-optimize/","excerpt":"","text":"优化 Laravel 网站打开速度 关闭 debug打开.env 文件，把 debug 设置为 false. barryvdh/laravel-debugbar等开发环境使用的包一定要放在require-dev,线上就不要载入了，就算载入也要关闭。 缓存路由和配置php artisan route:cache。如果路由中有闭包是会报错的,所以路由中就不要添加处理逻辑php artisan config:cache composer 优化composer dump-autoload –optimize Laravel 优化命令php artisan optimize 使用 Laravel 缓存$lists = Cache::remember('key', 20, function () { return $this->destination->getList(); }); 使用 PHP7 并开启 OPcache开启opcache后需要重启 php-fpm哦 nginx 开启 gzip 压缩Nginx 开启 gzip 可以有效减少服务器带宽的消耗，缺点是会增大 CPU 的占用率，但是很多时候 CPU 往往是空闲最多的。在nginx的配置中添加如下: gzip on; gzip_min_length 1k; gzip_buffers 16 64k; gzip_http_version 1.1; gzip_comp_level 9; gzip_types text/plain application/x-javascript application/javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml; gzip_vary on; GZIP_MIN_LENGTH 设置允许压缩的页面最小字节数，页面字节数从 header 头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大。 即: gzip_min_length 1024 响应头中 Content-Encoding 字段是 gzip，表示该网页是经过 gzip 压缩的。 使用swoole来laravel优化项目我们这里使用laravels来优化laravel5.5 composer require “hhxsv5/laravel-s:~3.5.0” -vvv 配置ningx的代理到swoole端口。Nginx的配置,使用的是proxy_pass+upstream。 由于swoole是常驻内存，所以单例的写法和HTTP请求参数获取需要注意，下面会说。 如果某些包在加入swoole后出现了异常，可以用一个中间件来重置单例对象的状态。 upstream laravels { # 通过 IP:Port 连接 server 127.0.0.1:5200 weight=5 max_fails=3 fail_timeout=30s; # 通过 UnixSocket Stream 连接，小诀窍：将socket文件放在/dev/shm目录下，可获得更好的性能 #server unix:/xxxpath/laravel-s-test/storage/laravels.sock weight=5 max_fails=3 fail_timeout=30s; #server 192.168.1.1:5200 weight=3 max_fails=3 fail_timeout=30s; #server 192.168.1.2:5200 backup; keepalive 16; } server { listen 80; server_name laravels.valsun.cn; root /data/web/niftyAdmin/public/; error_log /data/web/niftyAdmin/storage/logs/error.log error; access_log /data/web/niftyAdmin/storage/logs/access.log main; index index.php; location / { try_files $uri @laravels; } location @laravels { # proxy_connect_timeout 60s; # proxy_send_timeout 60s; # proxy_read_timeout 120s; proxy_http_version 1.1; proxy_set_header Connection \"\"; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Real-PORT $remote_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header Scheme $scheme; proxy_set_header Server-Protocol $server_protocol; proxy_set_header Server-Name $server_name; proxy_set_header Server-Addr $server_addr; proxy_set_header Server-Port $server_port; proxy_pass http://laravels; } } 压测PHP 7.0.11 + Laravel5.5服务器配置，就一个小型测试项目在跑，装有一个mysql服务。 top - 11:30:03 up 396 days, 10:08, 2 users, load average: 0.14, 5.14, 7.21 Tasks: 315 total, 1 running, 297 sleeping, 16 stopped, 1 zombie Cpu0 : 16.3%us, 4.3%sy, 0.0%ni, 75.4%id, 2.0%wa, 0.0%hi, 1.3%si, 0.7%st Cpu1 : 1.7%us, 1.7%sy, 0.0%ni, 96.4%id, 0.0%wa, 0.0%hi, 0.0%si, 0.3%st Cpu2 : 1.0%us, 2.0%sy, 0.0%ni, 96.7%id, 0.3%wa, 0.0%hi, 0.0%si, 0.0%st Cpu3 : 1.3%us, 1.3%sy, 0.0%ni, 97.4%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu4 : 1.3%us, 1.3%sy, 0.0%ni, 97.4%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu5 : 9.3%us, 2.7%sy, 0.0%ni, 88.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu6 : 1.0%us, 3.0%sy, 0.0%ni, 96.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu7 : 0.7%us, 2.3%sy, 0.0%ni, 97.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Mem: 16333892k total, 15396272k used, 937620k free, 191568k buffers Swap: 0k total, 0k used, 0k free, 10030768k cached [root@tracknumber_share niftyAdmin]# free -m total used free shared buffers cached Mem: 15951 15036 914 0 187 9797 -/+ buffers/cache: 5051 10899 Swap: 0 0 0 测试都是在本地使用简单的ab测试，目的只是想横向对比 php-fpm + nginx 和 swoole + nginx 的性能 ./ab -n 5000 -c 500 http://nt.valsun.cn/api/getData 逻辑很简单,启用laravel5.5的框架通过api路由直接输出,laravel已经使用上面的优化措施 public function getData() { echo '3123123'; } nginx + php-fpm 测试结果压测时服务器的指标 top - 11:41:58 up 396 days, 10:20, 2 users, load average: 17.20, 12.25, 11.45 ab压测结果 Server Software: BWS Server Hostname: nt.valsun.cn Server Port: 80 Document Path: /api/getData Document Length: 1436 bytes Concurrency Level: 1000 Time taken for tests: 10.291 seconds Complete requests: 5000 Failed requests: 954 (Connect: 0, Receive: 0, Length: 954, Exceptions: 0) Non-2xx responses: 5000 Total transferred: 7339154 bytes HTML transferred: 5967972 bytes Requests per second: 485.84 [#/sec] (mean) Time per request: 2058.296 [ms] (mean) Time per request: 2.058 [ms] (mean, across all concurrent requests) Transfer rate: 696.42 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 2 42.5 1 3004 Processing: 112 1783 1146.6 1527 3988 Waiting: 8 1579 1098.9 1368 3978 Total: 113 1785 1146.8 1528 3989 Percentage of the requests served within a certain time (ms) 50% 1528 66% 1751 75% 2064 80% 2434 90% 3946 95% 3969 98% 3977 99% 3978 100% 3989 (longest request) nginx + swoole 压测压测时服务器的指标 top - 11:43:03 up 399 days, 10:21, 4 users, load average: 5.31, 2.59, 2.12 ./ab -k -t 30 -c 1000 http://laravels.valsun.cn/api/getData Benchmarking laravels.valsun.cn (be patient) Completed 5000 requests Completed 10000 requests Completed 15000 requests Completed 20000 requests Completed 25000 requests Completed 30000 requests Completed 35000 requests Completed 40000 requests Completed 45000 requests Completed 50000 requests Finished 50000 requests Server Software: BWS Server Hostname: laravels.valsun.cn Server Port: 80 Document Path: /api/getData Document Length: 38 bytes Concurrency Level: 1000 Time taken for tests: 14.921 seconds Complete requests: 50000 Failed requests: 1772 (Connect: 0, Receive: 0, Length: 1772, Exceptions: 0) Non-2xx responses: 1772 Keep-Alive requests: 48228 Total transferred: 13281128 bytes HTML transferred: 2158712 bytes Requests per second: 3351.01 [#/sec] (mean) Time per request: 298.417 [ms] (mean) Time per request: 0.298 [ms] (mean, across all concurrent requests) Transfer rate: 869.24 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.3 0 11 Processing: 4 284 163.2 248 1243 Waiting: 4 274 142.4 247 1134 Total: 4 284 163.3 248 1243 Percentage of the requests served within a certain time (ms) 50% 248 66% 288 75% 323 80% 348 90% 449 95% 612 98% 875 99% 976 100% 1243 (longest request) 这个采用2种ab测试方法主要是 php-fpm 用-t测试并发太高 request fail的比率就太高了，就是用柔和的方式测试。 从测试结果也看出来了swoole提升的性能很大，而且服务器的负载完全没有起来。 但是用swoole常驻内存需要注意下一些事项。 swoole常驻内存注意事项laravels的注意事项 应通过Illuminate\\Http\\Request对象来获取请求信息 $_ENV是可读取的，$_SERVER是部分可读的，不能使用$_GET、$_POST、$_FILES、$_COOKIE、$_REQUEST、$_SESSION、$GLOBALS 推荐通过返回Illuminate\\Http\\Response对象来响应请求，兼容echo、vardump()、print_r()，不能使用函数像 dd()、exit()、die()、header()、setcookie()、http_response_code() 各种单例的连接将被常驻内存，建议开启持久连接 你声明的全局、静态变量必须手动清理或重置 无限追加元素到静态或全局变量中，将导致内存爆满 是用swoole优化之后 尽量不适用static 声明静态变量,也没有那个必要,这里有简单的方法去偷懒,就是把laravels.php配置文件中的 max_request降低一点这样它重启的频率就会大一点，以免单进程的内存暴了 单例问题 ,laravel框架到处都用了单例。 传统FPM下，单例模式的对象的生命周期仅在每次请求中，请求开始=&gt;实例化单例=&gt;请求结束后=&gt;单例对象资源回收。 Swoole Server下，所有单例对象会常驻于内存，这个时候单例对象的生命周期与FPM不同，请求开始=&gt;实例化单例=&gt;请求结束=&gt;单例对象依旧保留，需要开发者自己维护单例的状态 详见laravels文档,作者提供了详细的解决方案主要就是 Session,Passport,JWT的使用 如果要使用laravels，强烈建议先把这个laravels结构熟读于心，并且了解初始larvel的功能,毕竟常驻内存和平常的php-fpm编程还是有很大的不同 引入laravels 不仅仅是提高了并发，而且可以方便的使用swoole的功能，比如websocket,协程，多进程等 由于larvels是常驻内存，所以每次修改代码之后要看见效果就需要重启./bin/laravels reload，这个作者也提供了解决方案哦 自动reload laravels 初步在小型项目使用 ，用户认证包括(session 和jwt) ,Eloquent ORM,路由，Artisan 命令行 ，Blade模板渲染都没有问题。","categories":[{"name":"php","slug":"php","permalink":"http://wyq2214368.github.io/categories/php/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://wyq2214368.github.io/tags/laravel/"}]},{"title":"Swoole 协程","slug":"swoole/coroutine","date":"2019-04-28T16:00:00.000Z","updated":"2019-06-25T06:35:53.930Z","comments":true,"path":"2019/04/29/swoole/coroutine/","link":"","permalink":"http://wyq2214368.github.io/2019/04/29/swoole/coroutine/","excerpt":"","text":"Swoole 协程协程可以理解为纯用户态的线程，其通过协作而不是抢占来进行切换。相对于进程或者线程，协程所有的操作都可以在用户态完成，创建和切换的消耗更低。协程主要用于优化IO操作频繁的任务,当然这个IO需要使用异步IO，能够yeild的异步IO。 yield 实现协程多任务调度这里有两篇分享很好讲诉了使用yeild来实现生成器，从而实现协程多任务调度，PHP 多任务协程处理，PHP 协程实现，借花献佛哈哈。主要分以下两步。这个和Python的asyncio协程实现很像。asyncio.event_loop:程序开启一个无限循环，把一些函数注册到事件循环上，当满足事件发生的时候，调用相应的协程函数。asyncio.task:一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含了任务的各种状态。 TaskTask 是普通生成器的装饰器。我们将生成器赋值给它的成员变量以供后续使用，然后实现一个简单的 run() 和 finished() 方法。run() 方法用于执行任务，finished() 方法用于让调度程序知道何时终止运行。 class Task { protected $generator; protected $run = false; public function __construct(Generator $generator) { $this->generator = $generator; } public function run() { if ($this->run) { //判断是否是第一次run,第一次用next那直接会跑到第二个yield $this->generator->next(); } else { $this->generator->current(); } $this->run = true; } public function finished() { return !$this->generator->valid(); } } SchedulerScheduler 用于维护一个待执行的任务队列。run() 会弹出队列中的所有任务并执行它，直到运行完整个队列任务。如果某个任务没有执行完毕，当这个任务本次运行完成后，我们将再次入列。 class Scheduler { protected $queue; public function __construct() { $this->queue = new SplQueue(); //FIFO 队列 } public function enqueue(Task $task) { $this->queue->enqueue($task); } public function run() { while (!$this->queue->isEmpty()) { $task = $this->queue->dequeue(); $task->run(); if (!$task->finished()) { $this->queue->enqueue($task); } } } } 使用$scheduler = new Scheduler(); $task1 = new Task(call_user_func(function() { for ($i = 0; $i &lt; 3; $i++) { print \"task1: \" . $i . \"\\n\"; yield sleep(1); //挂起IO操作 } })); $task2 = new Task(call_user_func(function() { for ($i = 0; $i &lt; 6; $i++) { print \"task2: \" . $i . \"\\n\"; yield sleep(1); //挂起IO操作 } })); $scheduler->enqueue($task1); $scheduler->enqueue($task2); $startTime = microtime(true); $scheduler->run(); print \"用时: \".(microtime(true) - $startTime); 执行结果交替执行,task1执行到yeild交出控制权，轮到task2执行到yeild再交出控制权，再一次轮到task1，直到task1执行完，队列里只剩下task2自我陶醉了。虽然执行结果是这样的，但是效果并不是我们想要的,执行了9秒那和我们同步执行有什么区别，因为sleep()是同步阻塞的，接下来我们把sleep换一下。 task1: 0 task1: 1 task2: 0 task2: 1 task1: 2 task2: 2 task2: 3 task2: 4 task2: 5 用时: 9.0115599632263 异步sleep需要用到swoole,co::sleep()是swoole自带的异步sleep,go()是 swoole协程 的创建命令 function async_sleep($s){ return go(function ()use($s) { co::sleep($s); // 模拟请求接口、读写文件等I/O }); } $scheduler = new Scheduler(); $task1 = new Task(call_user_func(function() { for ($i = 0; $i &lt; 3; $i++) { print \"task1: \" . $i . \"\\n\"; yield async_sleep(1); } })); $task2 = new Task(call_user_func(function() { for ($i = 0; $i &lt; 6; $i++) { print \"task2: \" . $i . \"\\n\"; yield async_sleep(1); } })); $scheduler->enqueue($task1); $scheduler->enqueue($task2); $startTime = microtime(true); $scheduler->run(); print \"用时: \".(microtime(true) - $startTime); 执行结果，这应该就我们想要的IO操作异步并发,一共9个IO实际时间=1个IO,如果这个异步IO是异步mysql，异步http等就大大提升了我们脚本的并发能力 task1: 0 task2: 0 task1: 1 task2: 1 task1: 2 task2: 2 task2: 3 task2: 4 task2: 5 用时: 1.0025930404663 Swoole 协程从4.0版本开始Swoole提供了完整的协程(Coroutine)+通道(Channel)特性。应用层可使用完全同步的编程方式，底层自动实现异步IO。这句话是swoole说的。 for ($i = 0; $i &lt; 10; ++$i) { // swoole 创建协程 go(function () use ($i) { co::sleep(1.0); // 模拟异步请求接口、读写文件等I/O var_dump($i); }); } swoole_event_wait(); //异步阻塞等所有协程完成任务 print \"协程用时: \".(microtime(true) - $time); 运行时间是1秒这里就不多说了。协程之所以快是因异步IO可以yield，但是我们平常使用的mysql请求，http请求等都是同步的,就算使用协程调度也提升不了并发，这不swooleg提供了我们想要的东东。 Swoole 协程MySQL客户端swoole的Coroutine\\MySQL具体操作可以看这里,代码中举了异步和同步的mysql请求和并发试一下， dump需要引入symfony,方便打印对象的结构。 //异步mysql function asyncMysql(){ go(function () { $db = new \\Swoole\\Coroutine\\Mysql(); $server = array( 'host' => '127.0.0.1', 'user' => 'root', 'password' => '123456', 'database' => 'test', 'port' => '3306', ); $db->connect($server); //异步 $result = $db->query('select * from users limit 1'); // dump( $result); }); } //同步msql function synMysql(){ $servername = \"127.0.0.1\"; $username = \"root\"; $password = \"123456\"; $dbname = \"test\"; $conn = mysqli_connect($servername, $username, $password, $dbname); if (!$conn) { die(\"连接失败: \" . mysqli_connect_error()); } $sql = \"select * from users limit 1\"; $result = mysqli_query($conn, $sql); if (mysqli_num_rows($result) > 0) { while($row = mysqli_fetch_assoc($result)) { // dump($row); } } else { echo \"0 结果\"; } mysqli_close($conn); } $startTime = microtime(true); for($i=0;$i&lt;100;$i++){ asyncMysql(); } swoole_event_wait(); $endTime = microtime(true); dump($endTime-$startTime); 异步所花时间 0.029722929000854 0.017247200012207 0.029895067214966 0.024247884750366 同步所花时间 0.086297988891602 0.083254814147949 0.0831139087677 0.083254814147949 看运行时间不太对哈,这个怎么差了这么一点。我想的是这样的哈，Coroutine\\MySQL 上面的例子异步IO操作应该是 connect 和 query，其他的例如创建客户端那就是同步操作了，这个消耗是同步阻塞的,而且占了比例不小,所以才出现这样的情况。那想一下我们是不是可以这样写，把mysql异步客服端直接拿出来让协程共享。 function asyncMysql(){ go(function(){ $db = new \\Swoole\\Coroutine\\Mysql(); $server = array( 'host' => '127.0.0.1', 'user' => 'root', 'password' => '4QqRbtNCc3LnHko4LQ9H', 'database' => 'tracknumer_share', 'port' => '3306', ); $db->connect($server); $startTime = microtime(true); for($i=0;$i&lt;10;$i++){ go(function ()use($db) { $result = $db->query('select * from users limit 1'); }); } swoole_event_wait(); $endTime = microtime(true); dump($endTime-$startTime); }); } [2019-04-30 11:23:36 @4769.0] ERROR check_bind (ERROR 10002): mysql client has already been bound to another coroutine#2, reading or writing of the same socket in multiple coroutines at the same time is not allowed. Stack trace: #0 Swoole\\Coroutine\\MySQL->query() called at [/data/web/dev/swoole-demo/src/Coroutine/mysql.php:44] 哦天哪发生了什么，报错了，它说这个mysql客户端已经有其他协程占用了。是我太天真的了。官网说swoole这样做是为了防止多个协程同一时刻使用同一个客户端导致数据错乱。那我们就简单实现一个mysql的连接池,复用协程客户端，实现长连接。 Swoole 协程MySQL连接池&lt;?php require __DIR__ . '/../bootstrap.php'; class MysqlPool { protected $available = true; public $pool; protected $config; //mysql服务的配置文件 protected $max_connection = 100;//连接池大小 protected $current_connection = 0;//当前链接池数 public function __construct($config) { $this->config = $config; $this->pool = new SplQueue; } public function put($mysql) { $this->pool->push($mysql); } /** * @return bool|mixed|\\Swoole\\Coroutine\\Mysql */ public function get() { //有空闲连接且连接池处于可用状态 if ($this->available &amp;&amp; $this->pool->length > 0) { return $this->pool->pop(); } //无空闲连接，创建新连接 $mysql = $this->newMysqlClient(); if ($mysql == false) { return false; } else { return $mysql; } } protected function newMysqlClient() { if($this->current_connection >= $this->max_connection){ throw new Exception(\"链接池已经满了\"); } $this->current_connection++; $mysql = new Swoole\\Coroutine\\Mysql(); $mysql->connect($this->config); return $mysql; } public function destruct() { // 连接池销毁, 置不可用状态, 防止新的客户端进入常驻连接池, 导致服务器无法平滑退出 $this->available = false; while (!$this->pool->isEmpty()) { go(function(){ $mysql = $this->pool->pop(); $mysql->close(); }); } } public function __destruct(){ $this->destruct(); } } $config = array( 'host' => '127.0.0.1', 'user' => 'root', 'password' => '123456', 'database' => 'test', 'port' => '3306', ); $pool = new MysqlPool($config); 好了，一个简单的连接池已经搞好了,我先用一下 go(function()use($config){ $pool = new MysqlPool($config); for($i=0;$i&lt;2;$i++){ go(function ()use($pool) { $mysql = $pool->get(); $result = $mysql->query('select * from users limit 1'); dump($result); $pool->put($mysql); }); } dump($pool); }); 好了结果出来了，新增一个defer()，在协程推出之前释放连接池的资源。 go(function()use($pool){ $pool = new MysqlPool($config); defer(function () use ($pool) { //用于资源的释放, 会在协程关闭之前(即协程函数执行完毕时)进行调用, 就算抛出了异常, 已注册的defer也会被执行. echo \"Closing connection pool\\n\"; $pool->destruct(); }); for($i=0;$i&lt;2;$i++){ go(function ()use($pool) { $mysql = $pool->get(); $result = $mysql->query('select * from users limit 1'); dump($result); $pool->put($mysql); }); } dump($pool); }); 这个有一个比较完善的 协程客户端链接池包 Swoole 协程 Channel 实现并发数据收集这里使用子协程+通道来并发收集数据，理想的情况是使用连接池,但是会遇到问题。 //每个子进程创建一个mysql连接 go(function()use($pool,$config){ $chan = new chan(10); for($i=0;$i&lt;2;$i++){ go(function()use($pool,$chan,$config){ $mysql = new \\Swoole\\Coroutine\\Mysql(); $mysql->connect($config); $result = $mysql->query('select * from users limit 1'); $chan->push($result); $mysql->close(); }); } for($i=0;$i&lt;2;$i++){ dump($chan->pop());//这个pop()如果遇到空会yield,直到子协程的push()数据之后才会重新唤醒 } }); //使用连接池 $pool = new MysqlPool($config); go(function()use($pool,$config){ $chan = new chan(10); for($i=0;$i&lt;2;$i++){ go(function()use($pool,$chan,$config){ $mysql = $pool->get(); $result = $mysql->query('select * from users limit 1'); $chan->push($result); $pool->put($mysql);//这里如果不put回去，脚本就不会阻塞，不知道为啥，希望有大佬解惑！不put回去就要mysql->close()，等于每次都新建连接 }); } for($i=0;$i&lt;2;$i++){ dump($chan->pop());//这个pop()如果遇到空会yield,直到子协程的push()数据之后才会重新唤醒 } }); 过了一圈swoole协程感觉还是没有Python的asyncio包好用，有些地方总是搞不明白。","categories":[{"name":"php","slug":"php","permalink":"http://wyq2214368.github.io/categories/php/"}],"tags":[{"name":"swoole","slug":"swoole","permalink":"http://wyq2214368.github.io/tags/swoole/"}]},{"title":"利用反射机制实现基本的依赖注入","slug":"php/反射","date":"2019-04-10T16:00:00.000Z","updated":"2019-06-25T06:35:53.927Z","comments":true,"path":"2019/04/11/php/fan-she/","link":"","permalink":"http://wyq2214368.github.io/2019/04/11/php/fan-she/","excerpt":"","text":"ReflectionClass实现了 Reflector 接口，使得我们可以使用该类查看另一个类的相关信息。所谓的反射，大概的意思就是将一个类的相关信息给反射 (映射、反映) 出来，转载。 无依赖的情况要实例化一个类，获得其类名即可，实际项目中还需要结合自动加载，这里为了方便说明情况，就将所有类写在同一个文件中。这个操作很简单。 &lt;?php namespace Models; class Car { } namespace Framework; class App { public function getInstance($className) { //实例化 ReflectionClass 对象 $reflector = new \\ReflectionClass($className); if (!$reflector->isInstantiable()) { //不能被实例化的逻辑 return false; } //获取构造器 $constructor = $reflector->getConstructor(); //如果没有构造器，直接实例化 if (!$constructor) { //这里用了变量来动态的实例化类 return new $className; } } } $app = new App(); $car = $app->getInstance('Models\\Car'); var_dump($car); //输出 object(Models\\Car)#4 (0) { } 带有多层依赖的情况假设有一个汽车依赖底盘，底盘依赖轮胎和轴承，轮胎也依赖轴承，轴承无依赖。那么当需要实例化一个汽车类时，不友好的方式是这样的，$car = new Car(new Chassis(new Tyre(new Axle), new Axle())) ，打脑阔。 利用依赖注入是这样的。 &lt;?php namespace Framework; //定义一个类，用于实现依赖注入 class App { public function getInstance($className) { //实例化 ReflectionClass 对象 $reflector = new \\ReflectionClass($className); if (!$reflector->isInstantiable()) { //不能被实例化的逻辑，抽象类和接口不能被实例化 return false; } //获取构造器 $constructor = $reflector->getConstructor(); //如果没有构造器，也就是没有依赖，直接实例化 if (!$constructor) { return new $className; } //如果有构造器，先把构造器中的参数获取出来 $parameters = $constructor->getParameters(); //再遍历 parameters ，找出每一个类的依赖，存到 dependencies 数组中 $dependencies = array_map(function ($parameter) { /** * 这里是递归的去寻找每一个类的依赖，例如第一次执行的时候，程序发现汽车 Car 类依赖底盘 Chassis * 类，此时 $parameter 是一个ReflectionParameter 的实例，接着调用 ReflectionParameter * 的 getClass() 方法，获得一个 ReflectionClass 的实例，再接着调用 ReflectionClass * 的 getName() 方法，取得类名，也就是 Models\\Chassis ，但此时此刻还不能直接去 new * Models\\Chassis ，因为 Models\\Chassis 也有依赖，故要递归的去调用 getInstance * 进一步去寻找该类的依赖，周而复始，直到触发上面的 if(!$constructor) ，停止递归。 */ return $this->getInstance($parameter->getClass()->getName()); }, $parameters); //最后，使用 ReflectionClass 类提供的 newInstanceArgs ，方法去实例化类，参数将会传入构造器中 return $reflector->newInstanceArgs($dependencies); } } namespace Models; class Car { protected $chassis; //汽车依赖底盘 public function __construct(Chassis $chassis) { $this->chassis = $chassis; } } class Chassis { protected $tyre; protected $axle; //底盘依赖轮胎和轴承 public function __construct(Tyre $tyre, Axle $axle) { $this->tyre = $tyre; $this->axle = $axle; } } class Tyre { protected $axle; //轮胎也依赖轴承 public function __construct(Axle $axle) { $this->axle = $axle; } } class Axle { //轴承无依赖 } $app = new \\Framework\\App(); $car = $app->getInstance('Models\\Car'); var_dump($car); 处理构造方法中的 普通参数class Car { protected $chassis; protected $width; //汽车依赖底盘 public function __construct(Chassis $chassis, $width) // &lt;-----多加入了一个参数且不限定类型 { $this->chassis = $chassis; $this->width = $width; } } 运行代码，报错 call to function getName() on null ，问题出在了 return $this-&gt;getInstance($parameter-&gt;getClass()-&gt;getName()) 这一行，原因是 $parameter-&gt;getClass() 的结果是 null，这也是必然的。查看手册发现这样的一段描述，ReflectionParameter::getClass — Get the type hinted class (获取所提示的类)，上面加入的 $width ，没有做类型提示，$parameter-&gt;getClass() 得到的结果必然是 null 。 故，将有类型提示的和没有类型提示的分开处理。需要这样处理 &lt;?php namespace Framework; class App { public function getInstance($className) { $reflector = new \\ReflectionClass($className); if (!$reflector->isInstantiable()) { return false; } $constructor = $reflector->getConstructor(); if (!$constructor) { return new $className; } $parameters = $constructor->getParameters(); $dependencies = array_map(function ($parameter) { if (null == $parameter->getClass()) { //处理没有类型提示的参数 return $this->processNoHinted($parameter); } else { //处理有类型提示的参数 return $this->processHinted($parameter); } }, $parameters); return $reflector->newInstanceArgs($dependencies); } protected function processNoHinted(\\ReflectionParameter $parameter) { if ($parameter->isDefaultValueAvailable()) { return $parameter->getName(); } else { //参数为空则抛出异常 throw new \\Exception($parameter->getName() . \"不能为空\", 1); } } protected function processHinted(\\ReflectionParameter $parameter) { return $this->getInstance($parameter->getClass()->getName()); } } namespace Models; class Car { protected $chassis; protected $width; public function __construct(Chassis $chassis, $width = 2) { $this->chassis = $chassis; $this->width = $width; } } class Chassis { protected $tyre; protected $axle; public function __construct(Tyre $tyre, Axle $axle) { $this->tyre = $tyre; $this->axle = $axle; } } class Tyre { protected $axle; public function __construct(Axle $axle) { $this->axle = $axle; } } class Axle { } $app = new \\Framework\\App(); $car = $app->getInstance('Models\\Car'); var_dump($car);","categories":[{"name":"php","slug":"php","permalink":"http://wyq2214368.github.io/categories/php/"}],"tags":[{"name":"反射","slug":"反射","permalink":"http://wyq2214368.github.io/tags/反射/"}]},{"title":"PHP 守护进程","slug":"php/daemon","date":"2019-02-17T16:00:00.000Z","updated":"2019-06-25T06:35:53.922Z","comments":true,"path":"2019/02/18/php/daemon/","link":"","permalink":"http://wyq2214368.github.io/2019/02/18/php/daemon/","excerpt":"","text":"PHP 守护进程守护进程是一种运行在后台的特殊进程，因为它不属于任何一个终端，所以不会收到任何终端发来的任何信号。它与前台进程显著的区别是： 它没有控制终端，不能直接和用户交互，在后台运行； 它不受用户登录和注销的影响，只受开机或关机的影响，可以长期运行； 通常我们编写的程序，都需要在 后台不终止的长期运行 ，此时就可以使用守护进程。当然，我们可以在代码中调用系统函数，或者直接在启动命令后追加&amp;操作符，如下：$ nohup php server.php start &amp; 通常&amp;与 nohup 结合使用，忽略 SIGHUP 信号来实现一个守护进程。该方式对业务代码侵入最小，方便且成本低，常用于临时执行任务脚本的场景。 守护进程要点 进程守护化 使用 pcntl_fork()创建子进程，终止父进程,使得程序在 shell 终端里造成一个已经运行完毕的假象,一般会fork2次。 protected static function daemonize() { $pid = pcntl_fork(); if (-1 === $pid) { exit(\"process fork fail\\n\"); } elseif ($pid > 0) { //父进程直接退出 exit(0); } // 将当前进程提升为会话leader if (-1 === posix_setsid()) { exit(\"process setsid fail\\n\"); } //改变工作目录 chdir('/'); //重设文件创建的掩码 umask(0); // 再次fork以避免SVR4这种系统终端再一次获取到进程控制 $pid = pcntl_fork(); if (-1 === $pid) { exit(\"process fork fail\\n\"); } elseif ($pid > 0) { exit(0); } } 在子进程中创建新的会话会话是一个或多个进程组的集合，一个会话有对应的控制终端。setsid 函数用于创建一个新的会话，并担任该会话组的组长。调用 setsid 的三个作用：让进程摆脱原会话的控制、让进程摆脱原进程组的控制和让进程摆脱原控制终端的控制。在调用 fork 函数时，子进程全盘拷贝父进程的会话期 (session，是一个或多个进程组的集合)、进程组、控制终端等，虽然父进程退出了，但原先的会话期、进程组、控制终端等并没有改变，因此，那还不是真正意义上使两者独立开来。setsid 函数能够使进程完全独立出来，从而脱离所有其他进程的控制。 改变工作目录使用 fork 创建的子进程也继承了父进程的当前工作目录。由于在进程运行过程中，当前目录所在的文件系统不能卸载，因此，把当前工作目录换成其他的路径，如 “/” 或 “/tmp” 等。改变工作目录的常见函数是 chdir。 重设文件创建掩码文件创建掩码是指屏蔽掉文件创建时的对应位。由于使用 fork 函数新建的子进程继承了父进程的文件创建掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件创建掩码设置为 0，可以大大增强该守护进程的灵活性。设置文件创建掩码的函数是 umask，通常的使用方法为 umask (0)。 重定向标准输入输出用 fork 新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读或写，但它们一样消耗系统资源，可能导致所在的文件系统无法卸载。 protected static function resetStdFd() { global $STDIN, $STDERR, $STDOUT; //重定向标准输出和错误输出 @fclose(STDIN); @fclose(STDOUT); @fclose(STDERR); $STDIN = fopen('/dev/null', 'r'); $STDOUT = fopen(static::$stdoutFile, 'a'); $STDERR = fopen(static::$stdoutFile, 'a'); } 如果你关闭了标准输出，标准错误输出文件描述符，那么你打开的前三个文件描述符将成为新的标准输入、输出、错误的描述符。使用$STDIN, $STDOUT纯粹是障眼法而已, 必须指定为全局变量，否则文件描述符将在函数执行完毕之后被释放。 信号处理在 Linux 系统中，可使用kill -l命令查看这 62 个信号值,使用信号来实现进程间通信并控制进程的行为，注册信号处理器如下： function installSignal() { pcntl_signal(SIGINT, 'signalHandler', false); pcntl_signal(SIGTERM, 'signalHandler', false); pcntl_signal(SIGUSR1, 'signalHandler', false); pcntl_signal(SIGQUIT, 'signalHandler', false); // 忽略信号 pcntl_signal(SIGUSR2, SIG_IGN, false); pcntl_signal(SIGHUP, SIG_IGN, false); } function signalHandler($signal) { switch($signal) { case SIGINT: case SIGTERM: static::stop(); break; case SIGQUIT: case SIGUSR1: static::reload(); break; default: break; } } 其中，SIGINT 和 SIGTERM 信号会触发stop操作，即终止所有进程；SIGQUIT 和 SIGUSR1 信号会触发reload操作，即重新加载所有 Worker 进程；此处忽略了 SIGUSR2 和 SIGHUP 信号，但是并未忽略 SIGKILL 信号，即所有进程都可以被强制kill掉。 Show My Codeclass Daemon { protected $daemonize = false;//是否进程守护化 protected $stdoutFile = '/dev/daemon.log'; //重定向标准输出文件 设置之后可以查看守护进程的错误 protected $pidFile; //子进程pid文件 const PIDPATH = '/var/run/'; //默认的进程pid保存路径 public function __construct() { $this->setPidFile(); } /** * 创建守护进程核心函数 * @return string|void */ private function daemonize() { if(!$this->daemonize){ return; } $this->checkPcntl(); //创建子进程 $pid = pcntl_fork(); if ($pid == -1) { exit(\"process fork fail\\n\"); } elseif ($pid) { //终止父进程 exit(0); } //在子进程中创建新的会话 if (posix_setsid() === -1) { die('Could not detach'); } // 再次fork以避免SVR4这种系统终端再一次获取到进程控制 $pid = pcntl_fork(); if ($pid == -1) { exit(\"process fork fail\\n\"); } elseif (0 !== $pid) { exit(0); } chdir('/');//改变工作目录 umask(0);//重设文件创建的掩码 $this->saveMasterPid();//保存pid $this->setProcessTitle();//设置进程名字 $this->resetStdFd();//关闭文件描述符 return; } /** * 守护进程的任务，子类重写job，执行自定义方法 */ public function job() { //TODO 你的守护经常需要执行的任务 while (true) { // echo 'job process'.PHP_EOL; file_put_contents('/var/job.log', 'do job' . PHP_EOL, FILE_APPEND); sleep(2); } } /** * 设置 进程pid保存文件 之类可以重新自定义pidFile路径 * @return void */ public function setPidFile($file=''){ if(empty($file)){ $this->pidFile = static::PIDPATH.get_called_class().'_server.pid'; //get_called_class 继承之后获取的是之类的名字,或者使用后期静态绑定 }else{ $this->pidFile = $file; } } /** * 保存pid以实现stop */ protected function saveMasterPid() { $fp = fopen($this->pidFile, 'w') or die(\"Can't create pid file\"); //把当前进程的id写入到文件中 fwrite($fp, posix_getpid()); fclose($fp); } /** * 获取守护进程的id * @return int */ private function getPid() { //判断存放守护进程id的文件是否存在 if (!file_exists($this->pidFile)) { return 0; } $pid = intval(file_get_contents($this->pidFile)); if (posix_kill($pid, SIG_DFL)) {//判断该进程是否正常运行中 return $pid; } else { unlink($this->pidFile); return 0; } } /** * 关闭标准输出和错误输出. */ protected function resetStdFd() { global $STDERR, $STDOUT; //重定向标准输出和错误输出 @fclose(STDOUT); @fclose(STDERR); $STDOUT = fopen($this->stdoutFile, 'a'); $STDERR = fopen($this->stdoutFile, 'a'); } /** * 设置进程名. * * @param string $title 进程名. */ protected static function setProcessTitle($title='') { if(empty($title)){ $title = get_called_class().'Server'; } if (extension_loaded('proctitle') &amp;&amp; function_exists('setproctitle')) { @setproctitle($title); } elseif (version_compare(phpversion(), \"5.5\", \"ge\") &amp;&amp; function_exists('cli_set_process_title')) { @cli_set_process_title($title); } } /** * 判断pcntl拓展 */ private function checkPcntl() { !function_exists('pcntl_signal') &amp;&amp; die('Error:Need PHP Pcntl extension!'); } private function message($message) { printf(\"%s %d %s\" . PHP_EOL, date(\"Y-m-d H:i:s\"), $this->getPid(), $message); } /** * 开启守护进程 */ private function start() { if ($this->getPid() > 0) { $this->message('Running'); } else { $this->daemonize(); $this->message('Start'); $this->job(); } } /** * 停止守护进程 */ private function stop() { $pid = $this->getPid(); if ($pid > 0) { //通过向进程id发送终止信号来停止进程 posix_kill($pid, SIGTERM); unlink($this->pidFile); echo $pid.' Stoped' . PHP_EOL; } else { echo \"Not Running\" . PHP_EOL; } } private function status() { if ($this->getPid() > 0) { $this->message('Is Running'); } else { echo 'Not Running' . PHP_EOL; } } public function run() { global $argv; $command = isset($argv[1]) ? $argv[1] : ''; $command2 = isset($argv[2]) ? $argv[2] : ''; switch ($command) { case 'start': if ($command2 === '-d') { $this->daemonize = true; } $this->start(); break; case 'stop': $this->stop(); break; case 'status': $this->status(); break; default: echo \"Argv request start|stop|status \" . PHP_EOL; break; } } } php deamon.php start 正常运行 php deamon.php start -d 进程守护化运行 php deamon.php status 查看进程运行状态 php deamon.php stop 停止运行 使用将Daemon作为基类,子类继承Deamon自定义job class Work extends Daemon { public function job(){ //TODO 你的守护经常需要执行的任务 while (true) { // echo 'job process'.PHP_EOL; file_put_contents('/var/job.log', 'do work job' . PHP_EOL, FILE_APPEND); sleep(2); } } } $work = new Work(); $work->run();","categories":[{"name":"php","slug":"php","permalink":"http://wyq2214368.github.io/categories/php/"}],"tags":[{"name":"daemon","slug":"daemon","permalink":"http://wyq2214368.github.io/tags/daemon/"}]},{"title":"PHP多进程","slug":"php/fork","date":"2019-02-14T16:00:00.000Z","updated":"2019-06-25T06:35:53.923Z","comments":true,"path":"2019/02/15/php/fork/","link":"","permalink":"http://wyq2214368.github.io/2019/02/15/php/fork/","excerpt":"","text":"PHP多进程 pcntl_fork()函数成功执行时会在父进程返回子进程的进程id(pid)，因为系统的初始进程init进程的pid为1，后来产生进程的pid都会大于此进程，所以我们可以通过判断pcntl_fork()的返回值大于1来确实当前进程是父进程；而在子进程中，此函数的返回值会是固定值0，我们也可以通过判断pcntl_fork()的返回值为0来确定子进程； pcntl_fork()函数在执行失败时，会在父进程返回-1,当然也不会有子进程产生。 简单的子进程生成例子$pid = pcntl_fork(); if($pid == -1) { //错误处理：创建子进程失败时返回-1. die('fork error'); } else if ($pid) { //父进程会得到子进程号，所以这里是父进程执行的逻辑 echo \"parent \\n\"; //等待子进程中断，防止子进程成为僵尸进程。 pcntl_wait($status); } else { //子进程得到的$pid为0, 所以这里是子进程执行的逻辑。 echo \"child \\n\"; exit; } 多进程生成例子define('FORK_NUMS', 3); $pids = array(); for($i = 0; $i &lt; FORK_NUMS; ++$i) { $pids[$i] = pcntl_fork(); if($pids[$i] == -1) { die('fork error'); } else if ($pids[$i]) { pcntl_waitpid($pids[$i], $status); //等待指定进程退出 echo \"pernet \\n\"; } else { sleep(3); echo \"child id:\" . getmypid() . \" \\n\"; exit; //在子进程中,需通过exit来退出，不然会产生递归多进程,父进程中不需要exit,不然会中断多进程。 } } 多进程写入文件define('FORK_NUMS', 3); $pids = array(); $fp = fopen('./test.log', 'wb'); $num = 1; for($i = 0; $i &lt; FORK_NUMS; ++$i) { $pids[$i] = pcntl_fork(); if($pids[$i] == -1) { die('fork error'); } else if ($pids[$i]) { } else { for($i = 0; $i &lt; 5; ++$i) { flock($fp, LOCK_EX); //并发文件锁 fwrite($fp, getmypid() . ' : ' . date('Y-m-d H:i:s') . \" : {$num} \\r\\n\"); flock($fp, LOCK_UN); echo getmypid(), \": success \\r\\n\"; ++$num; } exit; } } foreach($pids as $k => $v) { if($v) { pcntl_waitpid($v, $status); //等待子进程完成 } } fclose($fp); 多进程生产封装用方法生产进程function createProcess($callback){ $pid = pcntl_fork(); if($pid &lt; 0){ die('fork error'); }else if($pid > 0){ return $pid ; }else{ $pid = posix_getpid(); $callback(); exit(\"child {$pid} process end\"); } } function handle($args){ print_r($args); echo 'handle'.PHP_EOL; sleep(3); } for($i=0;$i&lt;2;$i++){ $childList[] = createProcess('handle'); } //阻塞等子进程结束 foreach ($childList as $v) { if($v){ pcntl_waitpid($v, $status); } } print_r($childList); 用类生产进程class Process { private $callback; //进程处理方法 private $args;//进程处理参数 private $pid;//子进程pid private $ppid;//主进程id function __construct($callback,$args='') { $this->ppid = posix_getpid(); $this->callback = $callback; $this->args = $args; } /** * 生成子进程 */ public function run(){ $pid = pcntl_fork(); if($pid &lt; 0){ throw new Exception(\"fork error\"); }else if($pid > 0){ $this->pid = $pid; return $pid; }else{ posix_kill($this->ppid,0);//检查主进程是否存在 存在则返回true $callback = $this->callback; $callback($this->args); exit(); } } /** * 同步阻塞等子进程结束 */ public function join(){ return pcntl_waitpid($this->pid, $status); } } function handle($args){ print_r($args); echo 'handle'.PHP_EOL; sleep(3); } $p = []; for($i=0;$i&lt;2;$i++){ $cp = new Process('handle',[1,2,3]); $cp->run(); $p[] = $cp; } foreach ($p as $v) { $v->join(); } echo '主进程执行完毕'; 进程间通信（IPC）通常linux中的进程通信方式有：消息队列、信号量、共享内存、信号、管道、socket。转载 消息队列消息队列是存放在内存中的一个队列。如下代码将创建3个生产者子进程，2个消费者子进程。这5个进程将通过消息队列通信。由于消息队列取数据是原子性的,所以不需要锁或者信号量 $parentPid = posix_getpid(); echo \"parent progress pid:{$parentPid}\\n\";$childList = array(); // 创建消息队列,以及定义消息类型(类似于数据库中的库) $id = ftok(__FILE__,'m'); $msgQueue = msg_get_queue($id); const MSG_TYPE = 1; // 生产者 function producer(){ global $msgQueue; $pid = posix_getpid(); $repeatNum = 5; for ( $i = 1; $i &lt;= $repeatNum; $i++) { $str = \"({$pid})progress create! {$i}\"; msg_send($msgQueue,MSG_TYPE,$str); $rand = rand(1,3); sleep($rand); } } // 消费者 function consumer(){ global $msgQueue; $pid = posix_getpid(); $repeatNum = 6; for ( $i = 1; $i &lt;= $repeatNum; $i++) { $rel = msg_receive($msgQueue,MSG_TYPE,$msgType,1024,$message); echo \"{$message} | consumer({$pid}) destroy \\n\"; $rand = rand(1,3); sleep($rand); } } function createProgress($callback){ $pid = pcntl_fork(); if ( $pid == -1) { // 创建失败 exit(\"fork progress error!\\n\"); } else if ($pid == 0) { // 子进程执行程序 $pid = posix_getpid(); $callback(); exit(\"({$pid})child progress end!\\n\"); }else{ // 父进程执行程序 return $pid; } } // 3个写进程 for ($i = 0; $i &lt; 3; $i ++ ) { $pid = createProgress('producer'); $childList[$pid] = 1; echo \"create producer child progress: {$pid} \\n\"; } // 2个写进程 for ($i = 0; $i &lt; 2; $i ++ ) { $pid = createProgress('consumer'); $childList[$pid] = 1; echo \"create consumer child progress: {$pid} \\n\"; } // 等待所有子进程结束 while(!empty($childList)){ $childPid = pcntl_wait($status); if ($childPid > 0){ unset($childList[$childPid]); } } echo \"({$parentPid})main progress end!\\n\"; 信号信号是一种系统调用。通常我们用的kill命令就是发送某个信号给某个进程的。具体有哪些信号可以在liunx/mac中运行kill -l查看。php 中发送信号用 posix_kill($pid,SIGINT);下面这个例子中，父进程等待5秒钟，向子进程发送sigint信号。子进程捕获信号，掉信号处理函数处理。 $parentPid = posix_getpid(); echo \"parent progress pid:{$parentPid}\\n\"; // 定义一个信号处理函数 function sighandler($signo) { $pid = posix_getpid(); echo \"{$pid} progress,oh no ,I'm killed!\\n\"; exit(1); } $pid = pcntl_fork(); if ( $pid == -1) { // 创建失败 exit(\"fork progress error!\\n\"); } else if ($pid == 0) { // 子进程执行程序 // 注册信号处理函数 declare(ticks=10); pcntl_signal(SIGINT, \"sighandler\"); $pid = posix_getpid(); while(true){ echo \"{$pid} child progress is running!\\n\"; sleep(1); } exit(\"({$pid})child progress end!\\n\"); }else{ // 父进程执行程序 $childList[$pid] = 1; // 5秒后,父进程向子进程发送sigint信号. sleep(5); posix_kill($pid,SIGINT); sleep(5); } echo \"({$parentPid})main progress end!\\n\"; 信号量与共享内存 信号量：是系统提供的一种原子操作，一个信号量，同时只有你个进程能操作。一个进程获得了某个信号量，就必须被该进程释放掉。 共享内存：是系统在内存中开辟的一块公共的内存区域，任何一个进程都可以访问，在同一时刻，可以有多个进程访问该区域，为了保证数据的一致性，需要对该内存区域加锁或信号量。 $parentPid = posix_getpid(); echo \"parent progress pid:{$parentPid}\\n\"; $childList = array(); // 创建共享内存,创建信号量,定义共享key $shm_id = ftok(__FILE__,'m'); $sem_id = ftok(__FILE__,'s'); $shareMemory = shm_attach($shm_id); $signal = sem_get($sem_id); const SHARE_KEY = 1; // 生产者 function producer(){ global $shareMemory; global $signal; $pid = posix_getpid(); $repeatNum = 5; for ( $i = 1; $i &lt;= $repeatNum; $i++) { // 获得信号量 sem_acquire($signal); if (shm_has_var($shareMemory,SHARE_KEY)){ // 有值,加一 $count = shm_get_var($shareMemory,SHARE_KEY); $count ++; shm_put_var($shareMemory,SHARE_KEY,$count); echo \"({$pid}) count: {$count}\\n\"; }else{ // 无值,初始化 shm_put_var($shareMemory,SHARE_KEY,0); echo \"({$pid}) count: 0\\n\"; } // 用完释放 sem_release($signal); $rand = rand(1,3); sleep($rand); } } function createProgress($callback){ $pid = pcntl_fork(); if ( $pid == -1) { // 创建失败 exit(\"fork progress error!\\n\"); } else if ($pid == 0) { // 子进程执行程序 $pid = posix_getpid(); $callback(); exit(\"({$pid})child progress end!\\n\"); }else{ // 父进程执行程序 return $pid; } } // 3个写进程 for ($i = 0; $i &lt; 3; $i ++ ) { $pid = createProgress('producer'); $childList[$pid] = 1; echo \"create producer child progress: {$pid} \\n\"; } // 等待所有子进程结束 while(!empty($childList)){ $childPid = pcntl_wait($status); if ($childPid > 0){ unset($childList[$childPid]); } } // 释放共享内存与信号量 shm_remove($shareMemory); sem_remove($signal); echo \"({$parentPid})main progress end!\\n\"; 管道管道是比较常用的多进程通信手段，管道分为无名管道与有名管道，无名管道只能用于具有亲缘关系的进程间通信，而有名管道可以用于同一主机上任意进程。这里只介绍有名管道。下面的例子，子进程写入数据，父进程读取数据。 // 定义管道路径,与创建管道 $pipe_path = '/data/test.pipe'; if(!file_exists($pipe_path)){ if(!posix_mkfifo($pipe_path,0664)){ exit(\"create pipe error!\"); } } $pid = pcntl_fork(); if($pid == 0){ // 子进程,向管道写数据 $file = fopen($pipe_path,'w'); while (true){ fwrite($file,'hello world'); $rand = rand(1,3); sleep($rand); } exit('child end!'); }else{ // 父进程,从管道读数据 $file = fopen($pipe_path,'r'); while (true){ $rel = fread($file,20); echo \"{$rel}\\n\"; $rand = rand(1,2); sleep($rand); } }","categories":[{"name":"php","slug":"php","permalink":"http://wyq2214368.github.io/categories/php/"}],"tags":[{"name":"fork","slug":"fork","permalink":"http://wyq2214368.github.io/tags/fork/"}]},{"title":"RabbitMQ总结","slug":"rabbitmq","date":"2019-01-24T16:00:00.000Z","updated":"2019-06-25T06:35:53.929Z","comments":true,"path":"2019/01/25/rabbitmq/","link":"","permalink":"http://wyq2214368.github.io/2019/01/25/rabbitmq/","excerpt":"","text":"RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件） Rabbitmq特性 可靠性：持久化存储、ACK消息确认、发布confirm、事务支持。 灵活的路由：交换机功能。交换机类型：direct,topic,headers,fanout。 ha镜像，master-slave 多协议支持,集群节点 多语言客户端支持：java、c#、ruby、Python、php、c、scale、nodejs、go、erlang… 管理界面功能丰富、命令行rabbitmqctl、RPC远程调度 AMQP高级消息协议AMQP(高级消息队列协议) 是一个异步消息传递所使用的应用层协议规范，作为线路层协议，AMQP 客户端能够无视消息的来源任意发送和接受信息。AMQP四个重要组成部分： virtual host，虚拟主机 exchange，交换机 queue，队列 binding，绑定 一个虚拟主机持有一组交换机、队列和绑定。每台rabbitmq服务器可以有多个虚拟主机，默认为/。虚拟主机主要用于用户权限控制。因为RabbitMQ当中，用户只能在虚拟主机的粒度进行权限控制。因此，如果需要禁止A组访问B组的交换机/队列/绑定，必须为A和B分别创建一个虚拟主机。 队列（Queues）是你的消息（messages）的终点，可以理解成装消息的容器。队列是由消费者（Consumer）通过程序建立的，如果一个消费者试图创建一个已经存在的队列，RabbitMQ会直接忽略这个请求。 交换机（Exchange）可以理解成具有路由表的路由程序。每个消息都有一个称为路由键（routingkey）的属性，就是一个简单的字符串。每个交换机都是一个独立的进程，合理利用服务器多核CPU使得rabbitmq性能得到最佳。交换机有多种类型，不同的交换机类型CPU开销是不一样的，一般来说CPU开销顺序是: TOPIC &gt; DIRECT &gt; FANOUT &gt; NAMELESS 交换机类型消息不直接发送到queue中，中间有一个exchange做消息分发，producer甚至不知道消息发送到那个队列中去。因此，当exchange收到message时，必须准确知道该如何分发。是推送到一定规则的queue，还是推送到多个queue中，还是被丢弃。这些规则都是通过exchange去定义的。 匿名交换机，工作队列模式 扇形交换机（fanout），发布订阅/广播模式 直连交换机（direct），路由绑定/广播精确匹配 主题交换机（topic），路由规则/广播模糊匹配 头交换机（header），定义AMQP头部属性 相关特性持久化如果你没有特意告诉RabbitMQ，那么在它退出或者崩溃的时候，将会丢失所有队列和消息。已经定义过非持久化的队列不能再定义为持久化队列，我们得重新命名一个新的队列。必须把“队列”和“消息”都设为持久化。 //交换机持久化 $channel->exchange_declare('exchange', 'fanout', false, true, false); //队列持久化 $channel->queue_declare('task_queue', false, true, false, false); //消息持久化 $msg = new AMQPMessage($body, ['delivery_mode' => 2]); Ack消息确认当消息被RabbitMQ发送给消费者（consumers）之后，马上就会在内存中移除。这种情况，你只要把一个工作者（worker）停止，正在处理的消息就会丢失。同时，所有发送到这个工作者的还没有处理的消息都会丢失。我们不想丢失任何任务消息。如果一个工作者（worker）挂掉了，我们希望任务会重新发送给其他的工作者（worker）。为了防止消息丢失，RabbitMQ提供了消息响应（acknowledgments）。消费者会通过一个ack（响应），告诉RabbitMQ已经收到并处理了某条消息，然后RabbitMQ就会释放并删除这条消息。 $channel->basic_consume('task_queue', '', false, false, false, false, $callback); //在回调函数中发送ack消息 $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']); Qos公平调度如果多个worker进程中，某个worker处理比较慢，另一个worker比较快，默认RabbitMQ只管分发进入队列的消息，不会关心有多少消费者（consumer）没有作出响应，这样会使得比较慢的worker消息堆积过多，导致任务分配不均。Qos公平调度设置prefetch_count=1，即在同一时刻，不会发送超过1条消息给一个工作者（worker），直到它已经处理了上一条消息并且作出了响应。这样，RabbitMQ就会把消息分发给下一个空闲的工作者（worker）。 //$prefetch_size,$prefetch_count,$global $channel->basic_qos(null, 1, null); 消息事务将消息设为持久化并不能完全保证不会丢失。持久化只是告诉了RabbitMq要把消息存到硬盘，但从RabbitMq收到消息到保存之间还是有一个很小的间隔时间。因为RabbitMq并不是所有的消息都使用同步IO—它有可能只是保存到缓存中，并不一定会写到硬盘中。并不能保证真正的持久化，但已经足够应付我们的简单工作队列。如果你一定要保证持久化，我们需要改写代码来支持事务（transaction）。 $channel->tx_select(); $channel->basic_publish($msg, '', 'task_queue'); $channel->tx_commit(); confirm消息确认AMQP消息协议提供了事务支持，不过事务机制会导致性能急剧下降，所以rabbitmq特别引入了confirm机制。 Confirm有三种编程方式： 普通confirm模式。每发送一条消息后，调用wait_for_pending_acks()方法，等待服务器端confirm。实际上是一种串行confirm。 批量confirm模式。每次发送一批消息后，调用wait_for_pending_acks()方法，等待服务器端confirm。 异步confirm模式。提供一个回调方法，服务器端confirm了一条(或多条)消息后客户端会回调这个方法。 代码示例： //一旦消息被设为confirm模式，就不能设置事务模式，反之亦然 $channel->confirm_select(); //阻塞等待消息确认 $channel->wait_for_pending_acks(); //异步回调消息确认 $channel->set_ack_handle(); $channel->set_nack_handler(); PHP使用 Rabbitmq使用 php-amqplib/php-amqplib 进行二次封装可以满足基本需求 &lt;?php /* * rabbitMQ封装 */ namespace App\\Libraries\\MQ; // define('AMQP_PASSIVE', true); // define('AMQP_DEBUG', false); use App\\Exceptions\\AMQPException; use PhpAmqpLib\\Connection\\AMQPConnection; use PhpAmqpLib\\Message\\AMQPMessage; class AMQP{ private $channel; private $msg; private $conn; private $system; private $consumer_tag; private $isRePublish = false; private $mid; private $callback; private $config_path = 'queue.RMQ_CONFIG'; public function __construct($system = ''){ if(!empty($system)){ $this->connection($system); } } public function __destruct(){ $this->closeConnection(); } /** * 实例化后rabbitMQ连接 * @param string $system 系统名称 * @return bool */ public function connection($system){; if(empty($this->conn)){ return $this->resetConnection($system); } if($system != $this->system){ return $this->resetConnection($system); } return true; } /** * 强制重置rabbitMQ连接 * @param string $system 系统名称 * @return bool */ public function resetConnection($system){ $rmqconfig = config($this->config_path); if(isset($rmqconfig[$system])){ $this->closeConnection(); list($host, $user, $password, $port, $vhost) = $rmqconfig[$system]; $this->conn = new AMQPConnection($host, $port, $user, $password, $vhost ); if(!$this->conn->isConnected()){ throw new AMQPException($system.'链接失败'); } $this->consumer_tag = getNow().':'.getmypid(); $this->channel = $this->conn->channel(); $this->system = $system; // $this->ackHandler(); return true; }else{ throw new AMQPException('systme 没有配置'); } } /* * 设置消息体大小限制 * @param string|int $bytes 字节数 */ private function setBodySizeLimit($bytes=0){ $this->channel->setBodySizeLimit($bytes); } /* * 添加交换器 * @param string $ename 交换器名称 * @param string $type 交换器的消息传递方式 可选:'fanout','direct','topic','headers' * 'fanout':不处理(忽略)路由键，将消息广播给绑定到该交换机的所有队列 * 'diect':处理路由键，对路由键进行全文匹配。对于路由键为\"aaa_rain\"的消息只会分发给路由键绑定为\"aaa_rain\"的队列,不会分发给路由键绑定为\"aaa_music\"的队列 * 'topic':处理路由键，按模式匹配路由键。模式符号 \"#\" 表示一个或多个单词，\"*\" 仅匹配一个单词。如 \"aaa.#\" 可匹配 \"aaa.rain.music\"，但 \"aaa.*\" 只匹配 \"aaa.rain\"和\"aaa.music\"。只能用\".\"进行连接，键长度不超过255字节 * @param boolean $durable 是否持久化 * @param boolean $auto_delete 当所有绑定队列都不再使用时，是否自动删除该交换机 */ public function addExchange($ename, $type = 'fanout', $durable = true, $auto_delete = false){ $this->channel->exchange_declare($ename, $type, false, $durable, $auto_delete); } /* * 添加队列 * @param string $qname 队列名称 * @param boolean $durable 是否持久化 * @param boolean $exclusive 仅创建者可以使用的私有队列，断开后自动删除 * @param boolean $auto_delete 当所有消费客户端连接断开后，是否自动删除队列 * return int 该队列的ready消息数量 */ public function addQueue($qname, $durable = true, $exclusive = false, $auto_delete = false){ $this->channel->queue_declare($qname, false, $durable, $exclusive, $auto_delete); } /* * 绑定队列和交换器 * @param string $qname 队列名称 * @param string $ename 交换器名称 * @param string $routing_key 路由键 注:在fanout的交换器中路由键会被忽略 */ public function bind($qname, $ename, $routing_key = ''){ $this->channel->queue_bind($qname, $ename, $routing_key); } /* * 设置消费者预取消息数量 * @param string|int $count 预取消息数量 */ public function setQos($count = 1){ $this->channel->basic_qos(null, $count, null); } /** * 基础模型之消息发布 * @param string $exchange 交换器名称 * @param string|array $msg 发布内容 * @param string $mqtype 发布消息的类型 * @return bool */ public function basicPublish($msg, $exchang,$routing_key=''){ if(is_array($msg))$msg = json_encode($msg); $message = new AMQPMessage( $msg,array('content_type' => 'text/plain', 'delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT) ); $this->channel->basic_publish($message, $exchang,$routing_key); $this->publishLog($exchange,$routing_key,1); } /** * confirm pushlish * @param string $exchange 交换器名称 * @param string|array $msg 发布内容 * @param string $mqtype 发布消息的类型 * @return bool */ public function ackPublish($msg, $exchang,$routing_key=''){ $this->ackHandler(); $this->basicPublish($msg, $exchang,$routing_key); $this->waitAck(); $this->publishLog($exchange,$routing_key,1); } /** * 批量发布 * @param array $exchange 交换器名称 * @param string|array $msg 发布内容 * @param string $routing_key 路由 */ public function batchPublish($msg,$exchange,$routing_key=''){ if(!is_array($msg)){ throw new AMQPException(\"批量推送msg必须要为数组\"); } foreach ($msg as $v) { if(is_array($v))$v = json_encode($v); $message = new AMQPMessage($v, array('content_type' => 'text/plain', 'delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT)); $this->channel->batch_basic_publish($message,$exchange,$routing_key); } $this->channel->publish_batch(); $this->publishLog($exchange,$routing_key,count($msg)); } /** * 基础模型之消息接受 * @param string $exchange * @param string $queue * @param array $callback * @param string $mqtype * @return string */ public function basicConsume($queue , $callback, $no_ack = false){ $this->callback = $callback; $this->channel->basic_consume($queue, $this->consumer_tag, false, $no_ack, false, false, [$this,'process_message']); /* while(count($this->ch->callbacks)){ $this->channel->wait(); }*/ while (count($this->channel->callbacks)) { $read = array($this->conn->getSocket()); // add here other sockets that you need to attend $write = null; $except = null; if (false == ($num_changed_streams = stream_select($read, $write, $except, 60))) { throw new AMQPException(\"队列接受异常或队列消息为空\"); } elseif ($num_changed_streams > 0) { $this->channel->wait(); } } } /** * Pub/Sub 之批量消息接受，默认接受200条数据 * @param string $queue 队列名称 * @param int $limit 返回条数 * @return array */ public function batchGet($queue, $limit = 200){ $messageCount = $this->channel->queue_declare($queue, false, true, false, false); $i = 0; $max = $limit &lt; 200 ? $limit : 200; $data = []; while($i &lt; $messageCount[1] &amp;&amp; $i &lt; $max){ $this->msg = $this->channel->basic_get($queue); $this->channel->basic_ack($this->msg->delivery_info['delivery_tag']); $data[] = $this->msg->body; $i++; } return $data; } /** * 重推消息 * @param string|int $mid 重推消息id * @param string $exchange 交换器名称 * @param string|array $msg 发布内容 * @param string $routing_key 路由键 注:在fanout的交换器中路由键会被忽略 * @return bool */ public function rePublish($mid,$exchange, $msg, $routing_key=''){ $this->isRePublish = true; $this->mid = $mid; $msg = is_array($msg) ? json_encode($msg) : $msg; $tosend = new AMQPMessage($msg, array('content_type' => 'text/plain', 'delivery_mode' => 2)); $this->channel->basic_publish($tosend, $exchange, $routing_key); $this->waitAck(); $this->isRePublish = false;//为了防止之后调用其他推送方法出现异常 } /** * 销毁队列中的数据 * @param $msg_obj * @return bool */ public function basicAck($msg_obj){ $this->channel->basic_ack($msg_obj->delivery_info['delivery_tag']); } /** * 推送回调处理 */ public function ackHandler(){ $this->channel->set_ack_handler( function (AMQPMessage $message) { echo \"Message acked with content \" . $message->body . PHP_EOL; } ); $this->channel->set_nack_handler( function (AMQPMessage $message) { echo \"Message nacked with content \" . $message->body . PHP_EOL; } ); $this->channel->confirm_select(); } public function waitAck(){ $this->channel->wait_for_pending_acks(); } /** * 默认回调函数 * @param object $msg_obj * @return bool */ public function process_message($msg_obj){ $rerult = call_user_func($this->callback,$msg_obj); if(($rerult['ack'])){ $this->basicAck($msg_obj); } } /** * 关闭消费者 * @param $msg_obj * @return array */ public function cancelConsumer($msg_obj){ $msg_obj->delivery_info['channel']->basic_cancel($msg_obj->delivery_info['consumer_tag']); } public function closeConnection(){ if(is_object($this->channel)){ $this->channel->close(); } if(is_object($this->conn)){ $this->conn->close(); } } public function publishLog($exchange,$route,$count){ echo getNow().\"[交换机:{$exchange}][路由:{$route}][数量:$count]\".PHP_EOL; } }","categories":[{"name":"php","slug":"php","permalink":"http://wyq2214368.github.io/categories/php/"}],"tags":[{"name":"rabbitMQ","slug":"rabbitMQ","permalink":"http://wyq2214368.github.io/tags/rabbitMQ/"}]},{"title":"延迟队列","slug":"php/delay-queue","date":"2018-12-31T16:00:00.000Z","updated":"2019-06-25T06:35:53.922Z","comments":true,"path":"2019/01/01/php/delay-queue/","link":"","permalink":"http://wyq2214368.github.io/2019/01/01/php/delay-queue/","excerpt":"","text":"比如要实现30分钟未支付订单取消,量少的时候可以用数据库轮训的方式,但是数据量大的话，轮训的并发和准确性就不可靠,这个时候可以用延迟队列来解决这个问题 延迟队列的实现 [RabbitMQ] RabbitMQ通过RabbitMQ Delayed Message Plugin可支持延迟队列 [Redis] Redis的Sorted Set可被用于实现简单的延迟队列。利用Redis的Lua支持我们也可以将基建设成一个功能全面的延迟队列服务。 [Redis + RabbitMQ] redis用来消费任务不可靠，没有ack机制支持,如果消费的脚本出现异常,那这个任务就有可能丢失,redis可以仅仅用来做延迟,取到消息后直接推到 RabbitMQ 或者 Kafka 进行消费 Redis 实现延迟队列Sorted Set是一个有序的集合，集合内元素的排序基于其加入集合时指定的score。通过ZRANGEBYSCORE命令，我们可以取得score在指定区间内的元素。将集合中的元素做为消息，score视为延迟的时间，这便是一个延迟队列的模型。 生产者通过ZADD将消息发送到队列中： ZADD delay-queue 1520985600 \"publish article\" 消费者通过ZRANGEBYSCORE获取消息。如果时间未到，将得不到消息；当时间已到或已超时，都可以得到消息：ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。 127.0.0.1:6379> ZRANGEBYSCORE delay-queue -inf 1520985599 (empty list or set) 127.0.0.1:6379> ZRANGEBYSCORE delay-queue -inf 1520985600 WITHSCORES 1) \"publish article\" 2) \"1520985600\" 127.0.0.1:6379> ZRANGEBYSCORE delay-queue -inf 1520985601 WITHSCORES 1) \"publish article\" 2) \"1520985600\" 使用ZRANGEBYSCORE取得消息后，消息并没有从集合中删出。需要调用ZREM删除消息： 127.0.0.1:6379> ZREM delay-queue \"publish article\" 美中不足的是，消费者组合使用ZRANGEBYSCORE和ZREM的过程不是原子的，当有多个消费者时会存在竞争，可能使得一条消息被消费多次。此时需要使用Lua脚本保证消费操作的原子性： local message = redis.call('ZRANGEBYSCORE', KEYS[1], '-inf', ARGV[1], 'WITHSCORES', 'LIMIT', 0, 1); if #message > 0 then redis.call('ZREM', KEYS[1], message[1]); return message; else return {}; end","categories":[{"name":"php","slug":"php","permalink":"http://wyq2214368.github.io/categories/php/"}],"tags":[{"name":"延迟队列","slug":"延迟队列","permalink":"http://wyq2214368.github.io/tags/延迟队列/"}]},{"title":"Redis 分布式锁","slug":"php/redis-lock","date":"2018-12-03T16:00:00.000Z","updated":"2019-06-25T06:35:53.925Z","comments":true,"path":"2018/12/04/php/redis-lock/","link":"","permalink":"http://wyq2214368.github.io/2018/12/04/php/redis-lock/","excerpt":"","text":"实现一个分布式锁定，我们至少要考虑它能满足一下的这些需求: 互斥，就是要在任何的时刻，同一个锁只能够有一个客户端用户锁定. 不会死锁，就算持有锁的客户端在持有期间崩溃了，但是也不会影响后续的客户端加锁 谁加锁谁解锁，很好理解，加锁和解锁的必须是同一个客户端 Redis 分布式锁这里使用PRedis来访问Redis &lt;?php use PRedis; class RedisLock { protected is_block = 1; //获取阻塞获取锁 protected $_redis = null; /** * 当前请求id * @var integer */ protected static $request_id = ''; /** * 锁过期时间 * 单位：秒 * @var integer */ protected $expiredTime = 30; /** * 获取阻塞锁最长等待时间 * 不宜过长，请考虑实际情况单次锁释放时间设置 * 高并发情况，较长阻塞时间会造成大量进程堆积 * 单位：秒 * @var integer */ protected $waitTime = 10; /** * 阻塞锁重试频率 * 每次请求的间隔时间 * 单位: 微秒 * @var integer */ protected $frequency = 200; public function __construct() { $this->_redis = PRedis::connection('lock'); } public function lock($name, $policy=0, $config=[]) { $req_id = $this->getRequestId(); if ($policy === self::BLOCKED) { $result = 'false'; $beginTime = time(); while(true) { $result = $this->_redis->set($name, $req_id, 'PX', $this->expiredTime * 1000, 'NX'); if ('OK' === (string) $result) { return true; } elseif (time()-$beginTime&lt;=$this->waitTime) { usleep($this->frequency * 1000); } else { return false; } } return 'OK' === (string) $result; } else { $result = $this->_redis->set($name, $req_id, 'PX', $this->expiredTime * 1000, 'NX'); return 'OK' === (string) $result; } return false; } /** * 使用lua 保证原子操作,客户端 A 加锁成功后一段时间再来解锁，在执行删除 del 操作的时候锁过期了，而且这时候又有其他客户端 B 来加锁 (这时候加锁是肯定成功的，因为客户端 A 的锁过期了), 这时客户端 A 再执行删除 del 操作，会把客户端 B 的锁给清了. */ public function unlock($name) { $lua = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\"; $req_id = $this->getRequestId(); $result = $this->_redis->eval($lua, 1, $name, $req_id); return (int) $result === 1; } /** * @return $request_id 最好保证唯一值 */ protected function getRequestId() { $request_id = static::$request_id ?: (static::$request_id = uniqid()); return $request_id . getmypid(); } } $this-&gt;_redis-&gt;set($name, $req_id, ‘PX’, $this-&gt;expiredTime * 1000, ‘NX’); 第一个 name 是锁的名字，这个由具体业务逻辑控制，保证唯一即可，比如并发更新一个 sku的库存的时候 SKU0001就可以加上锁以免超卖 第二个是请求 ID,这样做的目的主要是为了保证加解锁的唯一性。这样我们就可以知道该锁是哪个客户端加的. 第三个参数是一个标识符，标识时间戳以毫秒为最小单位 具体的过期时间 这个参数是 NX, 表示当 key 不存在时我们才进行 set 操作，这样锁就不会形成覆盖。 分布式唯一ID使用的snowflack这个是编译安装，还有用swoole_lock实现的扩展包","categories":[{"name":"php","slug":"php","permalink":"http://wyq2214368.github.io/categories/php/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://wyq2214368.github.io/tags/redis/"}]},{"title":"Pypppeteer","slug":"python/pyppeteer","date":"2018-06-20T16:00:00.000Z","updated":"2019-06-25T06:35:53.928Z","comments":true,"path":"2018/06/21/python/pyppeteer/","link":"","permalink":"http://wyq2214368.github.io/2018/06/21/python/pyppeteer/","excerpt":"","text":"之前做爬虫或者浏览器自动化操作都用selenium ，再配合docker可以进行分布式部署,但是selenium太耗性能,这里有另外个选择puppeteer谷歌浏览器在17年自行开发了Chrome Headless特性，并与之同时推出了puppeteer，可以理解成我们日常使用的Chrome的无界面版本以及对其进行操控的js接口套装 pyppeteerimport asyncio from pyppeteer import launch async def main(): browser = await launch({'headless':False}) page = await browser.newPage() await page.goto('http://http://nifty.dwyjr.cn') await page.type('input[name=\"email\"]', 'yujiarong@sailvan.com', {\"delay\": 10}); await page.type('input[name=\"password\"]', 'yujiarong', {\"delay\": 10}); await page.click('#container > div.cls-content > div > div.panel-body > form > button') await page.screenshot({'path': 'example.png'}) cookies = await page.cookies() await browser.close() print( cookies) loop = asyncio.get_event_loop() tasks = [ asyncio.ensure_future(main()), asyncio.ensure_future(main()), asyncio.ensure_future(main()) ] loop.run_until_complete(asyncio.wait(tasks)) pyppeteer支持异步，具体操作可以直接看puppeteer的文档 ，pyppeteer的命令差不多 用来截屏 登陆获取cookie 爬去异步渲染的页面信息 并发操作默写不可描述的东西 嘿嘿","categories":[{"name":"python","slug":"python","permalink":"http://wyq2214368.github.io/categories/python/"}],"tags":[{"name":"pypppeteer","slug":"pypppeteer","permalink":"http://wyq2214368.github.io/tags/pypppeteer/"}]},{"title":"concurrent.futures 并发操作","slug":"python/futures-thread","date":"2018-05-10T16:00:00.000Z","updated":"2019-06-25T06:35:53.928Z","comments":true,"path":"2018/05/11/python/futures-thread/","link":"","permalink":"http://wyq2214368.github.io/2018/05/11/python/futures-thread/","excerpt":"","text":"concurrent.futures模块的基础是Exectuor，Executor是一个抽象类，它不能被直接使用。但是它提供的两个子类ThreadPoolExecutor和ProcessPoolExecutor却是非常有用，顾名思义两者分别被用来创建线程池和进程池的代码。我们可以将相应的tasks直接放入线程池/进程池，不需要维护Queue来操心死锁的问题，线程池/进程池会自动帮我们调度。 进程池from concurrent.futures import ProcessPoolExecutor import os,time,random def task(n): print('%s is running' %os.getpid()) time.sleep(2) return n**2 if __name__ == '__main__': p=ProcessPoolExecutor() #不填则默认为cpu的个数 l=[] start=time.time() for i in range(10): obj=p.submit(task,i) #submit()方法返回的是一个future实例，要得到结果需要用obj.result() l.append(obj) p.shutdown() #类似用from multiprocessing import Pool实现进程池中的close及join一起的作用 print('='*30) # print([obj for obj in l]) print([obj.result() for obj in l]) print(time.time()-start) #上面方法也可写成下面的方法 # start = time.time() # with ProcessPoolExecutor() as p: #类似打开文件,可省去.shutdown() # future_tasks = [p.submit(task, i) for i in range(10)] # print('=' * 30) # print([obj.result() for obj in future_tasks]) # print(time.time() - start) 线程池from concurrent.futures import ProcessPoolExecutor,ThreadPoolExecutor import threading import os,time,random def task(n): print('%s:%s is running' %(threading.currentThread().getName(),os.getpid())) time.sleep(2) return n**2 if __name__ == '__main__': p=ThreadPoolExecutor() #不填则默认为cpu的个数*5 l=[] start=time.time() for i in range(10): obj=p.submit(task,i) #异步 l.append(obj) p.shutdown() print('='*30) print([obj.result() for obj in l]) print(time.time()-start) #上面方法也可写成下面的方法 # start = time.time() # with ThreadPoolExecutor() as p: #类似打开文件,可省去.shutdown() # future_tasks = [p.submit(task, i) for i in range(10)] # print('=' * 30) # print([obj.result() for obj in future_tasks]) # print(time.time() - star asyncio.run_coroutine_threadsafe(do_some_work(4), new_loop)","categories":[{"name":"python","slug":"python","permalink":"http://wyq2214368.github.io/categories/python/"}],"tags":[{"name":"future","slug":"future","permalink":"http://wyq2214368.github.io/tags/future/"}]},{"title":"协程 asyncio","slug":"python/asyncio","date":"2018-04-10T16:00:00.000Z","updated":"2019-06-25T06:35:53.927Z","comments":true,"path":"2018/04/11/python/asyncio/","link":"","permalink":"http://wyq2214368.github.io/2018/04/11/python/asyncio/","excerpt":"","text":"关于asyncio的一些关键字的说明： event_loop 事件循环：程序开启一个无限循环，把一些函数注册到事件循环上，当满足事件发生的时候，调用相应的协程函数 coroutine 协程：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。 task 任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含了任务的各种状态 future: 代表将来执行或没有执行的任务的结果。它和task上没有本质上的区别 定义一个协程import asyncio import time now = lambda: time.time() async def do_some_work(x): print(\"waiting:\",x) await asyncio.sleep(x) return \"Done after {}s\".format(x) async def main(): coroutine1 = do_some_work(1) coroutine2 = do_some_work(2) coroutine3 = do_some_work(4) tasks = [ asyncio.ensure_future(coroutine1),#创建任务 asyncio.ensure_future(coroutine2), asyncio.ensure_future(coroutine3) ] return await asyncio.gather(*tasks) start = now() loop = asyncio.new_event_loop() results = loop.run_until_complete(main()) for result in results: print(\"Task ret:\",result) print(\"Time:\", now()-start) 执行结果 waiting: 1 waiting: 2 waiting: 4 Task ret: Done after 1s Task ret: Done after 2s Task ret: Done after 4s Time: 4.022229909896851 在上面带中我们通过async关键字定义一个协程（coroutine）,当然协程不能直接运行，需要将协程加入到事件循环loop中asyncio.get_event_loop：创建一个事件循环，然后使用run_until_complete将协程注册到事件循环，并启动事件循环。task对象是Future类的子类，保存了协程运行后的状态，用于未来获取协程的结果。使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行耗时的操作一般是一些IO操作，例如网络请求，文件读取等。我们使用asyncio.sleep函数来模拟IO操作。协程的目的也是让这些IO操作异步化。 线程协程很多时候，我们的事件循环用于注册协程，而有的协程需要动态的添加到事件循环中。一个简单的方式就是使用多线程。当前线程创建一个事件循环，然后在新建一个线程，在新线程中启动事件循环。当前线程不会被block。 import asyncio import time from threading import Thread now = lambda :time.time() def start_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() async def do_some_work(x): print('Waiting {}'.format(x)) await asyncio.sleep(x) print('Done after {}s'.format(x)) def more_work(x): print('More work {}'.format(x)) time.sleep(x) print('Finished more work {}'.format(x)) start = now() new_loop = asyncio.new_event_loop() t = Thread(target=start_loop, args=(new_loop,)) t.start() print('TIME: {}'.format(time.time() - start)) asyncio.run_coroutine_threadsafe(do_some_work(6), new_loop) asyncio.run_coroutine_threadsafe(do_some_work(4), new_loop) 上述的例子，主线程中创建一个new_loop，然后在另外的子线程中开启一个无限事件循环。 主线程通过run_coroutine_threadsafe新注册协程对象。这样就能在子线程中进行事件循环的并发操作，同时主线程又不会被block。一共执行的时间大概在6s左右。","categories":[{"name":"python","slug":"python","permalink":"http://wyq2214368.github.io/categories/python/"}],"tags":[{"name":"asyncio","slug":"asyncio","permalink":"http://wyq2214368.github.io/tags/asyncio/"}]},{"title":"yield 生成器 读取超大文件","slug":"php/yield","date":"2018-01-31T16:00:00.000Z","updated":"2019-06-25T06:35:53.926Z","comments":true,"path":"2018/02/01/php/yield/","link":"","permalink":"http://wyq2214368.github.io/2018/02/01/php/yield/","excerpt":"","text":"生成器函数的核心是yield关键字。它最简单的调用形式看起来像一个return申明，不同之处在于普通return会返回值并终止函数的执行，而yield会返回一个值给循环调用此生成器的代码并且只是暂停执行生成器函数。 读取超大文件function readTxt($file) { # code... $handle = fopen($file, 'rb'); while (feof($handle)===false) { # code... yield fgets($handle); } fclose($handle); } 形成斐波那数列function fb($n){ $a = 0;$b=1; while($n >0){ yield $b; list($b,$a) = [$a + $b,$b]; $n--; } } //如果用递归实现必须要cache节点数据,不然就是以指数增长的计算。 $map = []; function fbd($n){ global $map; if($n == 1)return 1; if($n == 2)return 2; echo 'aaaaaaa'.PHP_EOL; if(isset($map[$n]) ){ return $map[$n]; }else{ $data = f($n-1) + f($n-2); $map[$n] = $data; return $data; } }","categories":[{"name":"php","slug":"php","permalink":"http://wyq2214368.github.io/categories/php/"}],"tags":[{"name":"yield","slug":"yield","permalink":"http://wyq2214368.github.io/tags/yield/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-31T16:00:00.000Z","updated":"2019-06-25T06:35:53.921Z","comments":true,"path":"2018/01/01/hello-world/","link":"","permalink":"http://wyq2214368.github.io/2018/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wyq2214368.github.io/tags/hexo/"}]}]}